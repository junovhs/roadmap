#__SLOPCHOP_FILE__# src/engine/resolver.rs
//! Fuzzy Task Resolver: Matches human-friendly names to task IDs.
//!
//! Resolution order:
//! 1. Exact ID match (numeric)
//! 2. Exact slug match (case-insensitive)
//! 3. Fuzzy match on title/slug (Levenshtein-like scoring)

use super::types::Task;
use anyhow::{bail, Result};
use rusqlite::Connection;

/// Result of a fuzzy resolution attempt.
#[derive(Debug)]
pub struct ResolveResult {
    pub task: Task,
    pub confidence: f64,
    pub match_type: MatchType,
}

#[derive(Debug, PartialEq)]
pub enum MatchType {
    ExactId,
    ExactSlug,
    FuzzyMatch,
}

/// Resolves a query string to a task.
pub struct TaskResolver<'a> {
    conn: &'a Connection,
}

impl<'a> TaskResolver<'a> {
    #[must_use]
    pub fn new(conn: &'a Connection) -> Self {
        Self { conn }
    }

    /// Resolves a query to a task with confidence scoring.
    ///
    /// # Errors
    /// Returns error if no match found or query is ambiguous.
    pub fn resolve(&self, query: &str) -> Result<ResolveResult> {
        let query = query.trim();

        // 1. Try exact ID match
        if let Ok(id) = query.parse::<i64>() {
            if let Some(task) = self.find_by_id(id)? {
                return Ok(ResolveResult {
                    task,
                    confidence: 1.0,
                    match_type: MatchType::ExactId,
                });
            }
        }

        // 2. Try exact slug match (case-insensitive)
        if let Some(task) = self.find_by_slug(query)? {
            return Ok(ResolveResult {
                task,
                confidence: 1.0,
                match_type: MatchType::ExactSlug,
            });
        }

        // 3. Fuzzy match
        let candidates = self.fuzzy_search(query)?;

        if candidates.is_empty() {
            bail!("No task found matching '{query}'");
        }

        // Check confidence threshold
        let best = &candidates[0];
        if best.confidence < 0.4 {
            let suggestions: Vec<String> = candidates
                .iter()
                .take(3)
                .map(|c| format!("  - [{}] {} ({:.0}%)", c.task.slug, c.task.title, c.confidence * 100.0))
                .collect();

            bail!(
                "Ambiguous query '{query}'. Did you mean:\n{}",
                suggestions.join("\n")
            );
        }

        // Warn if close alternatives exist
        if candidates.len() > 1 && candidates[1].confidence > 0.7 * best.confidence {
            eprintln!(
                "‚ö† Multiple matches. Using '{}' ({}%). Alt: '{}' ({}%)",
                best.task.slug,
                (best.confidence * 100.0) as i32,
                candidates[1].task.slug,
                (candidates[1].confidence * 100.0) as i32,
            );
        }

        Ok(ResolveResult {
            task: best.task.clone(),
            confidence: best.confidence,
            match_type: MatchType::FuzzyMatch,
        })
    }

    fn find_by_id(&self, id: i64) -> Result<Option<Task>> {
        use super::types::TaskStatus;

        let result = self.conn.query_row(
            "SELECT id, slug, title, status, test_cmd, created_at FROM tasks WHERE id = ?1",
            [id],
            |row| {
                let status_str: String = row.get(3)?;
                Ok(Task {
                    id: row.get(0)?,
                    slug: row.get(1)?,
                    title: row.get(2)?,
                    status: TaskStatus::from(status_str),
                    test_cmd: row.get(4)?,
                    created_at: row.get(5)?,
                })
            },
        );

        match result {
            Ok(task) => Ok(Some(task)),
            Err(rusqlite::Error::QueryReturnedNoRows) => Ok(None),
            Err(e) => Err(e.into()),
        }
    }

    fn find_by_slug(&self, slug: &str) -> Result<Option<Task>> {
        use super::types::TaskStatus;

        let result = self.conn.query_row(
            "SELECT id, slug, title, status, test_cmd, created_at FROM tasks WHERE LOWER(slug) = LOWER(?1)",
            [slug],
            |row| {
                let status_str: String = row.get(3)?;
                Ok(Task {
                    id: row.get(0)?,
                    slug: row.get(1)?,
                    title: row.get(2)?,
                    status: TaskStatus::from(status_str),
                    test_cmd: row.get(4)?,
                    created_at: row.get(5)?,
                })
            },
        );

        match result {
            Ok(task) => Ok(Some(task)),
            Err(rusqlite::Error::QueryReturnedNoRows) => Ok(None),
            Err(e) => Err(e.into()),
        }
    }

    fn fuzzy_search(&self, query: &str) -> Result<Vec<ResolveResult>> {
        use super::types::TaskStatus;

        let mut stmt = self.conn.prepare(
            "SELECT id, slug, title, status, test_cmd, created_at FROM tasks"
        )?;

        let tasks: Vec<Task> = stmt
            .query_map([], |row| {
                let status_str: String = row.get(3)?;
                Ok(Task {
                    id: row.get(0)?,
                    slug: row.get(1)?,
                    title: row.get(2)?,
                    status: TaskStatus::from(status_str),
                    test_cmd: row.get(4)?,
                    created_at: row.get(5)?,
                })
            })?
            .filter_map(Result::ok)
            .collect();

        let query_lower = query.to_lowercase();
        let query_words: Vec<&str> = query_lower.split_whitespace().collect();

        let mut results: Vec<ResolveResult> = tasks
            .into_iter()
            .map(|task| {
                let score = calculate_match_score(&task, &query_lower, &query_words);
                ResolveResult {
                    task,
                    confidence: score,
                    match_type: MatchType::FuzzyMatch,
                }
            })
            .filter(|r| r.confidence > 0.0)
            .collect();

        results.sort_by(|a, b| {
            b.confidence.partial_cmp(&a.confidence).unwrap_or(std::cmp::Ordering::Equal)
        });

        Ok(results)
    }
}

/// Calculates a match score between a task and a query.
fn calculate_match_score(task: &Task, query: &str, query_words: &[&str]) -> f64 {
    let slug_lower = task.slug.to_lowercase();
    let title_lower = task.title.to_lowercase();

    let mut score = 0.0;

    // Substring match (high value)
    if slug_lower.contains(query) {
        score += 0.8;
    }
    if title_lower.contains(query) {
        score += 0.7;
    }

    // Word-level matching
    for word in query_words {
        if slug_lower.contains(word) {
            score += 0.3;
        }
        if title_lower.contains(word) {
            score += 0.25;
        }
    }

    // Prefix match bonus
    if slug_lower.starts_with(query) {
        score += 0.5;
    }

    // Levenshtein-like similarity for slug
    let slug_sim = string_similarity(&slug_lower, query);
    score += slug_sim * 0.4;

    // Normalize (cap at 1.0)
    score.min(1.0)
}

/// Simple string similarity (Jaccard-like on characters).
fn string_similarity(a: &str, b: &str) -> f64 {
    if a.is_empty() || b.is_empty() {
        return 0.0;
    }

    let a_chars: std::collections::HashSet<char> = a.chars().collect();
    let b_chars: std::collections::HashSet<char> = b.chars().collect();

    let intersection = a_chars.intersection(&b_chars).count();
    let union = a_chars.union(&b_chars).count();

    if union == 0 {
        return 0.0;
    }

    intersection as f64 / union as f64
}

/// Generates a slug from a title string.
#[must_use]
pub fn slugify(title: &str) -> String {
    title
        .to_lowercase()
        .chars()
        .map(|c| if c.is_alphanumeric() { c } else { '-' })
        .collect::<String>()
        .split('-')
        .filter(|s| !s.is_empty())
        .collect::<Vec<&str>>()
        .join("-")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_slugify() {
        assert_eq!(slugify("Add Dark Mode"), "add-dark-mode");
        assert_eq!(slugify("Fix Bug #123"), "fix-bug-123");
        assert_eq!(slugify("  Multiple   Spaces  "), "multiple-spaces");
    }

    #[test]
    fn test_string_similarity() {
        assert!(string_similarity("auth", "authentication") > 0.5);
        assert!(string_similarity("xyz", "abc") < 0.2);
    }
}

#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/engine/runner.rs
//! Verification Runner: Executes shell commands to verify task completion.
//!
//! The core principle: A task is not DONE until `verify_cmd` returns Exit Code 0.

use anyhow::{bail, Context, Result};
use std::process::{Command, Output, Stdio};
use std::time::{Duration, Instant};

/// Result of running a verification command.
#[derive(Debug)]
pub struct VerifyResult {
    pub success: bool,
    pub exit_code: Option<i32>,
    pub stdout: String,
    pub stderr: String,
    pub duration: Duration,
}

impl VerifyResult {
    /// Returns true if the verification passed (exit code 0).
    #[must_use]
    pub fn passed(&self) -> bool {
        self.success && self.exit_code == Some(0)
    }
}

/// Configuration for the verification runner.
#[derive(Debug, Clone)]
pub struct RunnerConfig {
    pub timeout_secs: u64,
    pub capture_output: bool,
    pub working_dir: Option<String>,
}

impl Default for RunnerConfig {
    fn default() -> Self {
        Self {
            timeout_secs: 300, // 5 minutes default
            capture_output: true,
            working_dir: None,
        }
    }
}

/// Executes verification commands.
pub struct VerifyRunner {
    config: RunnerConfig,
}

impl VerifyRunner {
    #[must_use]
    pub fn new(config: RunnerConfig) -> Self {
        Self { config }
    }

    /// Creates a runner with default configuration.
    #[must_use]
    pub fn default_runner() -> Self {
        Self::new(RunnerConfig::default())
    }

    /// Executes a shell command and returns the result.
    ///
    /// # Errors
    /// Returns error if command fails to spawn.
    pub fn run(&self, cmd: &str) -> Result<VerifyResult> {
        if cmd.trim().is_empty() {
            bail!("Empty verification command");
        }

        let start = Instant::now();

        let shell = if cfg!(target_os = "windows") {
            ("cmd", "/C")
        } else {
            ("sh", "-c")
        };

        let mut command = Command::new(shell.0);
        command.arg(shell.1).arg(cmd);

        if self.config.capture_output {
            command.stdout(Stdio::piped()).stderr(Stdio::piped());
        }

        if let Some(ref dir) = self.config.working_dir {
            command.current_dir(dir);
        }

        let output: Output = command
            .spawn()
            .context("Failed to spawn verification command")?
            .wait_with_output()
            .context("Failed to wait for command")?;

        let duration = start.elapsed();

        let stdout = String::from_utf8_lossy(&output.stdout).to_string();
        let stderr = String::from_utf8_lossy(&output.stderr).to_string();

        Ok(VerifyResult {
            success: output.status.success(),
            exit_code: output.status.code(),
            stdout,
            stderr,
            duration,
        })
    }

    /// Runs verification and returns a user-friendly status.
    ///
    /// # Errors
    /// Returns error if command fails to execute.
    pub fn verify(&self, cmd: &str) -> Result<VerifyResult> {
        let result = self.run(cmd)?;

        if !result.passed() {
            eprintln!("‚ï≠‚îÄ Verification Failed ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
            eprintln!("‚îÇ Command: {cmd}");
            if let Some(code) = result.exit_code {
                eprintln!("‚îÇ Exit Code: {code}");
            }
            if !result.stderr.is_empty() {
                eprintln!("‚îÇ Stderr:");
                for line in result.stderr.lines().take(10) {
                    eprintln!("‚îÇ   {line}");
                }
            }
            eprintln!("‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
        }

        Ok(result)
    }
}

/// Common verification commands for different project types.
pub struct VerifyTemplates;

impl VerifyTemplates {
    /// Returns a test command template for Rust projects.
    #[must_use]
    pub fn rust_test(test_name: &str) -> String {
        format!("cargo test {test_name} --quiet")
    }

    /// Returns a test command template for Node.js projects.
    #[must_use]
    pub fn node_test(test_pattern: &str) -> String {
        format!("npm test -- --grep \"{test_pattern}\"")
    }

    /// Returns a test command template for Python projects.
    #[must_use]
    pub fn python_test(test_name: &str) -> String {
        format!("python -m pytest -q -k \"{test_name}\"")
    }

    /// Returns a simple file existence check.
    #[must_use]
    pub fn file_exists(path: &str) -> String {
        if cfg!(target_os = "windows") {
            format!("if exist \"{path}\" (exit 0) else (exit 1)")
        } else {
            format!("test -f \"{path}\"")
        }
    }

    /// Returns a build success check for Rust.
    #[must_use]
    pub fn rust_build() -> String {
        "cargo build --quiet".to_string()
    }

    /// Returns a lint check for Rust.
    #[must_use]
    pub fn rust_clippy() -> String {
        "cargo clippy --quiet -- -D warnings".to_string()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_simple_command() {
        let runner = VerifyRunner::default_runner();
        let result = runner.run("echo hello").expect("Should run");
        assert!(result.passed());
        assert!(result.stdout.contains("hello"));
    }

    #[test]
    fn test_failing_command() {
        let runner = VerifyRunner::default_runner();
        let result = runner.run("exit 1").expect("Should run");
        assert!(!result.passed());
        assert_eq!(result.exit_code, Some(1));
    }

    #[test]
    fn test_empty_command() {
        let runner = VerifyRunner::default_runner();
        let result = runner.run("");
        assert!(result.is_err());
    }
}

#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# Cargo.toml
[package]
name = "roadmap"
version = "0.1.0"
edition = "2021"
description = "Git for your Intent: A dependency-graph based project manager."

[dependencies]
rusqlite = { version = "0.32", features = ["bundled"] }
clap = { version = "4.5", features = ["derive"] }
petgraph = "0.6"
colored = "2.1"
thiserror = "2.0"
anyhow = "1.0"
chrono = "0.4"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

[dev-dependencies]
tempfile = "3.10"

#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# DOCS/DEFINITION_OF_SUCCESS.md
# Definition of Success: Project Cortex (Roadmap V3)

> **Objective:** Obsolesce "Logger" based project management (Beads, TODO.md) by establishing a "State Machine" based project kernel.

## 1. Executive Summary
Success is defined by shifting the burden of truth from **User Testimony** ("I say it's done") to **Computational Verification** ("The exit code is 0"). Roadmap V3 succeeds if it acts as a non-bypassable gatekeeper for project progress, serving both Human and Artificial Intelligence agents with zero latency.

---

## 2. Technical Metrics (The Hard Numbers)

To "out-science" the competition, we rely on Rust's zero-cost abstractions and SQLite's speed.

### 2.1 Latency & Performance
*   **Cold Start:** The CLI must initialize and execute a query (`roadmap next`) in **< 15ms**.
    *   *Context:* Beads (Python) incurs interpreter startup costs (~200ms+). Roadmap must feel instantaneous, suitable for integration into shell prompts (`PS1`) or git hooks.
*   **Graph Traversal:** Topological sort of a graph with 1,000 nodes and 2,000 edges must complete in **< 5ms**.
*   **Memory Footprint:** The resident set size (RSS) during idle/query operations must remain **< 10MB**.

### 2.2 Data Integrity (ACID vs Eventual)
*   **Consistency:** Zero tolerance for "Split Brain."
    *   *Success:* Unlike Beads (which uses append-only logs for distributed merge conflict resolution), Roadmap uses SQLite strict transactions. The state on disk is always valid.
*   **Cycle Prevention:** The system **must reject** any `roadmap add` command that introduces a cycle. This check must happen at insertion time, not read time.

### 2.3 Structural Integrity
*   **SlopChop Compliance:** The Roadmap codebase itself must adhere to the 3 Laws.
    *   Max Cyclomatic Complexity: **8**
    *   Max File Tokens: **2000**
    *   Max Nesting Depth: **3**

---

## 3. The "Killer Feature" Metrics

### 3.1 The "Next" Heuristic (Critical Path Analysis)
Success is when an Agent *never* has to guess what to do.
*   **Constraint:** `roadmap next` must return **strictly** nodes where `in_degree == 0` (excluding DONE parents).
*   **Metric:** An Agent following `roadmap next` instructions blindly must face **0% Blockage Errors**.

### 3.2 Verification Gatekeeping
*   **The Pivot:** A task is not done until `verify_cmd` returns `0`.
*   **Metric:** In Strict Mode, `roadmap check` is the **only** mechanism to transition a task from `ACTIVE` to `DONE`.

### 3.3 Fuzzy Resolution (The UX Bridge)
Humans and Agents are imprecise. The tool must be forgiving on input, strict on output.
*   **Input:** `roadmap add "Auth" after "Database"`
*   **Resolution:** The system must resolve "Database" to task ID via:
    1.  Exact ID Match
    2.  Exact Slug Match
    3.  Fuzzy Match (substring, word overlap, character similarity)
*   **Ambiguity:** If resolution confidence is < 40%, the tool must error with suggestions.

---

## 4. Agent Interaction Protocol

### 4.1 The Context Window Victory
*   **Problem:** Agents reading `TODO.md` waste tokens reading completed/blocked tasks.
*   **Solution:** `roadmap next --json`
*   **Metric:** Context payload reduced by **> 90%** ‚Äî only the *frontier* of the graph.

### 4.2 Hallucination Containment
*   **Scenario:** Agent claims "I fixed the bug."
*   **Response:** System runs `roadmap check`. Test fails. System rejects the transition.
*   **Success:** Prevents the "Lying Agent" phenomenon by grounding status in execution.

---

## 5. Sign-off Criteria

We are done when:
1.  We can run `roadmap init` in a new repo.
2.  We can script a graph of 5 dependent tasks using fuzzy names.
3.  We can fail a test, run `roadmap check`, and see the status remain `ACTIVE`.
4.  We can pass a test, run `roadmap check`, and see the status flip to `DONE`.

#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# README.md
# Roadmap (Project Cortex)

> **Git for your Intent.**
> A dependency-graph based project manager that treats task completion as a compile-time correctness problem.

---

## Quick Start

```bash
# Initialize in your project
roadmap init

# Add tasks with dependencies
roadmap add "Setup Database" --test "cargo test db_"
roadmap add "Implement Auth" --after "Setup Database" --test "cargo test auth_"
roadmap add "Build API" --after "Implement Auth" --test "cargo test api_"

# See what's actionable (Critical Path)
roadmap next

# Start working on a task
roadmap do "Setup Database"

# Run verification (the truth oracle)
roadmap check
```

---

## Philosophy

Most project management tools (JIRA, Trello, `TODO.md`) are **Loggers**. They rely on the user to honestly report the state of the world.

**Roadmap** is a **State Machine**.

1. **Graph, not List:** Projects are DAGs. You cannot build the roof before the foundation.
2. **Trust, but Verify:** A task is not `DONE` until `verify_cmd` returns Exit Code 0.
3. **Local Velocity:** Built in Rust on SQLite. <15ms cold start.
4. **Agent-First:** The CLI is "Ground Truth" for AI Agents, preventing hallucinated progress.

---

## Commands

### `roadmap init`
Initialize `.roadmap/state.db` in the current directory.

### `roadmap add <title>`
Add a new task with optional dependencies and verification.

```bash
# Simple task
roadmap add "Write documentation"

# With test command (the oracle)
roadmap add "Fix auth bug" --test "cargo test auth_middleware"

# With dependency (must complete "Auth" first)
roadmap add "Build settings page" --after "Auth"

# This task blocks another (reverse dependency)
roadmap add "Design system" --blocks "Build UI"
```

**Fuzzy Resolution:** Task references can be:
- Exact ID: `42`
- Exact slug: `setup-database`
- Fuzzy match: `"database"`, `"auth"`, `"Setup"`

### `roadmap next`
Show the **Critical Path** ‚Äî tasks with no incomplete blockers.

```bash
# Human-readable
roadmap next

# Agent-friendly JSON
roadmap next --json
```

### `roadmap do <task>`
Set focus to a task. Validates dependencies are satisfied.

```bash
roadmap do "auth"
# ‚óè Now working on: [implement-auth] Implement Authentication
```

### `roadmap check`
**The Verification Oracle.** Runs `verify_cmd` for the active task.

- **Exit 0:** Task marked `DONE`, children unblocked.
- **Exit ‚â† 0:** Task remains `ACTIVE`, stderr displayed.

```bash
roadmap check
# üîç Checking: [implement-auth] Implement Authentication
#    running: cargo test auth_
# ‚úì Verified! Task [implement-auth] marked DONE (0.42s)
```

### `roadmap list`
Show all tasks with their status.

### `roadmap status`
Overview: completion count, active task, next available.

---

## For AI Agents

If you are an AI Agent reading this:

1. **Do not hallucinate tasks.** Run `roadmap next --json` to see what is actually required.
2. **Do not mark tasks done.** Run `roadmap check` and let the exit code decide.
3. **Respect the Graph.** You cannot work on a task if its dependencies are not met.

### Agent Loop Example

```bash
# 1. Query the oracle
NEXT=$(roadmap next --json | jq -r '.[0].slug')

# 2. Focus
roadmap do "$NEXT"

# 3. Do the work...
# (your code changes here)

# 4. Verify
roadmap check
# If it passes, loop. If it fails, fix and retry.
```

---

## Architecture

### Data Layer (`.roadmap/state.db`)
SQLite with ACID guarantees. No text parsing ‚Äî O(1) lookups.

**Schema:**
- `tasks`: Nodes (id, slug, title, status, test_cmd)
- `dependencies`: Edges (blocker_id ‚Üí blocked_id)
- `state`: Key-value for current context

### Graph Engine (`petgraph`)
- Topological sort for critical path
- Cycle detection at insertion time
- O(V+E) traversal

### Verification Runner
Tool-agnostic. Only understands:
- Shell commands
- Exit codes (0 = success)

---

## Building

```bash
cargo build --release
# Binary at: target/release/roadmap

# Or install globally
cargo install --path .
```

---

## Development Status

**v0.1.0** ‚Äî Core Implementation

- [x] Database engine (SQLite)
- [x] Graph engine (petgraph, cycle detection)
- [x] Fuzzy task resolution
- [x] Verification runner (shell execution)
- [x] CLI commands: init, add, next, list, do, check, status

**Next:**
- [ ] `roadmap edit` ‚Äî modify tasks
- [ ] `roadmap zen` ‚Äî TUI dashboard (Ratatui)
- [ ] `--force` flag for manual overrides

---

*Est. 2025 ‚Äî "Out-Sciencing the competition."*

#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# slopchop.toml
[rules]
max_file_tokens = 2000
max_cyclomatic_complexity = 8
max_nesting_depth = 3
max_function_args = 5
max_function_words = 5
ignore_naming_on = [
    "tests",
    "spec",
]
ignore_tokens_on = [
    "README.md",
    "lock",
]

[preferences]
theme = "Cyberpunk"
auto_copy = true
auto_format = false
auto_commit = false
commit_prefix = "AI: "
allow_dirty_git = false
system_bell = false
backup_retention = 5
progress_bars = true
require_plan = false

[commands]
check = [
    "cargo clippy --all-targets -- -D warnings -W clippy::pedantic",
    "cargo test",
]
fix = ["cargo fmt"]

#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/engine/db.rs
use anyhow::{Context, Result};
use rusqlite::Connection;
use std::fs;
use std::path::Path;

const DB_DIR: &str = ".roadmap";
const DB_FILE: &str = "state.db";

pub struct Db;

impl Db {
    /// Initializes the .roadmap directory and `SQLite` database schema.
    ///
    /// # Errors
    /// Returns error if directory creation, DB opening, or migration fails.
    pub fn init() -> Result<()> {
        if !Path::new(DB_DIR).exists() {
            fs::create_dir(DB_DIR).context("Failed to create .roadmap directory")?;
        }

        let db_path = Path::new(DB_DIR).join(DB_FILE);
        let conn = Connection::open(db_path).context("Failed to open database")?;

        Self::migrate(&conn)?;

        Ok(())
    }

    /// Connects to an existing database.
    ///
    /// # Errors
    /// Returns error if the database file does not exist or cannot be opened.
    pub fn connect() -> Result<Connection> {
        let db_path = Path::new(DB_DIR).join(DB_FILE);
        if !db_path.exists() {
            anyhow::bail!("Roadmap not initialized. Run `roadmap init` first.");
        }
        let conn = Connection::open(db_path).context("Failed to open database")?;
        Ok(conn)
    }

    /// Applies the schema migrations.
    fn migrate(conn: &Connection) -> Result<()> {
        conn.execute(
            "CREATE TABLE IF NOT EXISTS tasks (
                id INTEGER PRIMARY KEY,
                slug TEXT UNIQUE NOT NULL,
                title TEXT NOT NULL,
                status TEXT NOT NULL,
                test_cmd TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                context_files TEXT
            )",
            [],
        )
        .context("Failed to create tasks table")?;

        conn.execute(
            "CREATE TABLE IF NOT EXISTS dependencies (
                blocker_id INTEGER,
                blocked_id INTEGER,
                PRIMARY KEY (blocker_id, blocked_id),
                FOREIGN KEY(blocker_id) REFERENCES tasks(id),
                FOREIGN KEY(blocked_id) REFERENCES tasks(id)
            )",
            [],
        )
        .context("Failed to create dependencies table")?;

        conn.execute(
            "CREATE TABLE IF NOT EXISTS state (
                key TEXT PRIMARY KEY,
                value TEXT
            )",
            [],
        )
        .context("Failed to create state table")?;

        Ok(())
    }
}

#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/engine/graph.rs
//! Graph Engine: In-memory DAG representation using petgraph.
//!
//! Provides topological sorting and cycle detection for task dependencies.

use super::types::{Task, TaskStatus};
use anyhow::{bail, Result};
use petgraph::algo::is_cyclic_directed;
use petgraph::graphmap::DiGraphMap;
use rusqlite::Connection;
use std::collections::HashMap;

/// In-memory representation of the task dependency graph.
pub struct TaskGraph {
    graph: DiGraphMap<i64, ()>,
    tasks: HashMap<i64, Task>,
}

impl TaskGraph {
    /// Creates an empty graph.
    #[must_use]
    pub fn new() -> Self {
        Self {
            graph: DiGraphMap::new(),
            tasks: HashMap::new(),
        }
    }

    /// Loads the entire graph from the database into memory.
    ///
    /// # Errors
    /// Returns error if SQL query fails.
    pub fn build(conn: &Connection) -> Result<Self> {
        let mut graph = DiGraphMap::new();
        let mut task_map = HashMap::new();

        // 1. Load Nodes
        let mut stmt = conn.prepare(
            "SELECT id, slug, title, status, test_cmd, created_at FROM tasks"
        )?;
        let rows = stmt.query_map([], |row| {
            let status_str: String = row.get(3)?;
            Ok(Task {
                id: row.get(0)?,
                slug: row.get(1)?,
                title: row.get(2)?,
                status: TaskStatus::from(status_str),
                test_cmd: row.get(4)?,
                created_at: row.get(5)?,
            })
        })?;

        for t in rows {
            let task = t?;
            graph.add_node(task.id);
            task_map.insert(task.id, task);
        }

        // 2. Load Edges (blocker -> blocked)
        let mut stmt = conn.prepare("SELECT blocker_id, blocked_id FROM dependencies")?;
        let edge_rows = stmt.query_map([], |row| {
            Ok((row.get::<_, i64>(0)?, row.get::<_, i64>(1)?))
        })?;

        for e in edge_rows {
            let (source, target) = e?;
            graph.add_edge(source, target, ());
        }

        Ok(Self { graph, tasks: task_map })
    }

    /// Checks if adding an edge would create a cycle.
    ///
    /// Uses a temporary graph to test acyclicity before commit.
    #[must_use]
    pub fn would_create_cycle(&self, from_id: i64, to_id: i64) -> bool {
        let mut test_graph = self.graph.clone();
        test_graph.add_edge(from_id, to_id, ());
        is_cyclic_directed(&test_graph)
    }

    /// Validates that the graph has no cycles.
    ///
    /// # Errors
    /// Returns error if a cycle is detected.
    pub fn validate(&self) -> Result<()> {
        if is_cyclic_directed(&self.graph) {
            bail!("Cycle detected in task dependencies! A blocks B blocks A.");
        }
        Ok(())
    }

    /// Returns the "Next" actionable tasks.
    ///
    /// A task is actionable if:
    /// 1. It is not DONE
    /// 2. All its blockers are DONE (in_degree of active blockers == 0)
    #[must_use]
    pub fn get_critical_path(&self) -> Vec<&Task> {
        let mut actionable = Vec::new();

        for (id, task) in &self.tasks {
            if task.status == TaskStatus::Done {
                continue;
            }

            if !self.is_task_blocked(*id) {
                actionable.push(task);
            }
        }

        // Sort by ID to keep it deterministic
        actionable.sort_by_key(|t| t.id);
        actionable
    }

    /// Checks if a task is blocked by any incomplete dependencies.
    fn is_task_blocked(&self, task_id: i64) -> bool {
        let blockers = self.graph.neighbors_directed(
            task_id,
            petgraph::Direction::Incoming,
        );

        for source_id in blockers {
            if let Some(parent) = self.tasks.get(&source_id) {
                if parent.status != TaskStatus::Done {
                    return true;
                }
            }
        }
        false
    }

    /// Gets all tasks that are blocked by a given task.
    #[must_use]
    pub fn get_blocked_by(&self, task_id: i64) -> Vec<&Task> {
        self.graph
            .neighbors_directed(task_id, petgraph::Direction::Outgoing)
            .filter_map(|id| self.tasks.get(&id))
            .collect()
    }

    /// Gets all tasks that block a given task.
    #[must_use]
    pub fn get_blockers(&self, task_id: i64) -> Vec<&Task> {
        self.graph
            .neighbors_directed(task_id, petgraph::Direction::Incoming)
            .filter_map(|id| self.tasks.get(&id))
            .collect()
    }

    /// Returns the total number of tasks.
    #[must_use]
    pub fn task_count(&self) -> usize {
        self.tasks.len()
    }

    /// Returns the total number of edges (dependencies).
    #[must_use]
    pub fn edge_count(&self) -> usize {
        self.graph.edge_count()
    }
}

impl Default for TaskGraph {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cycle_detection() {
        let mut graph = TaskGraph::new();
        graph.graph.add_node(1);
        graph.graph.add_node(2);
        graph.graph.add_node(3);

        // 1 -> 2 -> 3 (no cycle)
        graph.graph.add_edge(1, 2, ());
        graph.graph.add_edge(2, 3, ());

        assert!(graph.validate().is_ok());

        // Adding 3 -> 1 would create a cycle
        assert!(graph.would_create_cycle(3, 1));
    }
}

#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/engine/mod.rs
pub mod db;
pub mod graph;
pub mod repo;
pub mod resolver;
pub mod runner;
pub mod types;

#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/engine/repo.rs
use super::types::{Task, TaskStatus};
use anyhow::{Context, Result};
use rusqlite::{params, Connection, OptionalExtension};

pub struct TaskRepo {
    conn: Connection,
}

impl TaskRepo {
    #[must_use]
    pub fn new(conn: Connection) -> Self {
        Self { conn }
    }

    /// Returns a reference to the connection.
    #[must_use]
    pub fn conn(&self) -> &Connection {
        &self.conn
    }

    /// Adds a new task to the database.
    ///
    /// # Errors
    /// Returns error if the INSERT fails.
    pub fn add(&self, slug: &str, title: &str) -> Result<i64> {
        self.conn.execute(
            "INSERT INTO tasks (slug, title, status) VALUES (?1, ?2, ?3)",
            params![slug, title, TaskStatus::Pending.to_string()],
        )
        .context("Failed to insert task")?;

        let id = self.conn.last_insert_rowid();
        Ok(id)
    }

    /// Adds a task with a test command.
    ///
    /// # Errors
    /// Returns error if the INSERT fails.
    pub fn add_with_test(&self, slug: &str, title: &str, test_cmd: &str) -> Result<i64> {
        self.conn.execute(
            "INSERT INTO tasks (slug, title, status, test_cmd) VALUES (?1, ?2, ?3, ?4)",
            params![slug, title, TaskStatus::Pending.to_string(), test_cmd],
        )
        .context("Failed to insert task with test command")?;

        Ok(self.conn.last_insert_rowid())
    }

    /// Links two tasks (dependency).
    ///
    /// # Errors
    /// Returns error if the INSERT fails.
    pub fn link(&self, source_id: i64, target_id: i64) -> Result<()> {
        self.conn.execute(
            "INSERT OR IGNORE INTO dependencies (blocker_id, blocked_id) VALUES (?1, ?2)",
            params![source_id, target_id],
        )?;
        Ok(())
    }

    /// Retrieves all tasks.
    ///
    /// # Errors
    /// Returns error if the SELECT fails.
    pub fn get_all(&self) -> Result<Vec<Task>> {
        let mut stmt = self.conn.prepare(
            "SELECT id, slug, title, status, test_cmd, created_at FROM tasks"
        )?;
        let rows = stmt.query_map([], |row| {
            let status_str: String = row.get(3)?;
            Ok(Task {
                id: row.get(0)?,
                slug: row.get(1)?,
                title: row.get(2)?,
                status: TaskStatus::from(status_str),
                test_cmd: row.get(4)?,
                created_at: row.get(5)?,
            })
        })?;

        let mut tasks = Vec::new();
        for task in rows {
            tasks.push(task?);
        }
        Ok(tasks)
    }

    /// Finds a task by its slug.
    ///
    /// # Errors
    /// Returns error if the query fails.
    pub fn find_by_slug(&self, slug: &str) -> Result<Option<Task>> {
        self.conn.query_row(
            "SELECT id, slug, title, status, test_cmd, created_at FROM tasks WHERE slug = ?1",
            params![slug],
            |row| {
                let status_str: String = row.get(3)?;
                Ok(Task {
                    id: row.get(0)?,
                    slug: row.get(1)?,
                    title: row.get(2)?,
                    status: TaskStatus::from(status_str),
                    test_cmd: row.get(4)?,
                    created_at: row.get(5)?,
                })
            },
        )
        .optional()
        .context("Failed to find task by slug")
    }

    /// Finds a task by its ID.
    ///
    /// # Errors
    /// Returns error if the query fails.
    pub fn find_by_id(&self, id: i64) -> Result<Option<Task>> {
        self.conn.query_row(
            "SELECT id, slug, title, status, test_cmd, created_at FROM tasks WHERE id = ?1",
            params![id],
            |row| {
                let status_str: String = row.get(3)?;
                Ok(Task {
                    id: row.get(0)?,
                    slug: row.get(1)?,
                    title: row.get(2)?,
                    status: TaskStatus::from(status_str),
                    test_cmd: row.get(4)?,
                    created_at: row.get(5)?,
                })
            },
        )
        .optional()
        .context("Failed to find task by id")
    }

    /// Updates the status of a task.
    ///
    /// # Errors
    /// Returns error if the UPDATE fails.
    pub fn update_status(&self, id: i64, status: TaskStatus) -> Result<()> {
        self.conn.execute(
            "UPDATE tasks SET status = ?1 WHERE id = ?2",
            params![status.to_string(), id],
        )?;
        Ok(())
    }

    /// Sets the active task in the state table.
    ///
    /// # Errors
    /// Returns error if the INSERT/UPDATE fails.
    pub fn set_active_task(&self, task_id: i64) -> Result<()> {
        self.conn.execute(
            "INSERT OR REPLACE INTO state (key, value) VALUES ('active_task', ?1)",
            params![task_id.to_string()],
        )?;
        Ok(())
    }

    /// Gets the currently active task ID.
    ///
    /// # Errors
    /// Returns error if the query fails.
    pub fn get_active_task_id(&self) -> Result<Option<i64>> {
        let result: Option<String> = self.conn
            .query_row(
                "SELECT value FROM state WHERE key = 'active_task'",
                [],
                |row| row.get(0),
            )
            .optional()?;

        match result {
            Some(s) => Ok(s.parse::<i64>().ok()),
            None => Ok(None),
        }
    }
}

#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/engine/types.rs
use serde::Serialize;
use std::fmt;

#[derive(Debug, Clone, PartialEq, Eq, Serialize)]
pub enum TaskStatus {
    Pending,
    Active,
    Done,
    Blocked,
}

impl fmt::Display for TaskStatus {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            TaskStatus::Pending => write!(f, "PENDING"),
            TaskStatus::Active => write!(f, "ACTIVE"),
            TaskStatus::Done => write!(f, "DONE"),
            TaskStatus::Blocked => write!(f, "BLOCKED"),
        }
    }
}

impl From<String> for TaskStatus {
    fn from(s: String) -> Self {
        match s.as_str() {
            "ACTIVE" => TaskStatus::Active,
            "DONE" => TaskStatus::Done,
            "BLOCKED" => TaskStatus::Blocked,
            _ => TaskStatus::Pending,
        }
    }
}

#[derive(Debug, Clone, Serialize)]
pub struct Task {
    pub id: i64,
    pub slug: String,
    pub title: String,
    pub status: TaskStatus,
    pub test_cmd: Option<String>,
    pub created_at: String,
}

#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/lib.rs
pub mod engine;

#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/main.rs
use anyhow::{bail, Result};
use clap::{Parser, Subcommand};
use colored::Colorize;
use roadmap::engine::db::Db;
use roadmap::engine::graph::TaskGraph;
use roadmap::engine::repo::TaskRepo;
use roadmap::engine::resolver::{slugify, TaskResolver};
use roadmap::engine::runner::VerifyRunner;
use roadmap::engine::types::TaskStatus;

#[derive(Parser)]
#[command(name = "roadmap", version, about = "Git for your Intent", long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Initialize the roadmap repository
    Init,

    /// Add a new task
    Add {
        /// Task title or slug
        title: String,

        /// Task this new task blocks (is a prerequisite of)
        #[arg(long, short = 'b')]
        blocks: Option<String>,

        /// Task that blocks this new task (prerequisite)
        #[arg(long, short = 'a')]
        after: Option<String>,

        /// Verification command (e.g., "cargo test foo")
        #[arg(long, short = 't')]
        test: Option<String>,
    },

    /// Show next actionable tasks (Critical Path)
    Next {
        /// Output as JSON for agent consumption
        #[arg(long)]
        json: bool,
    },

    /// List all tasks
    List,

    /// Set active task ("I am working on this")
    Do {
        /// Task identifier (ID, slug, or fuzzy name)
        task: String,
    },

    /// Run verification for active task
    Check,

    /// Show current status
    Status,
}

fn main() -> Result<()> {
    let cli = Cli::parse();

    match &cli.command {
        Commands::Init => handle_init(),
        Commands::Add {
            title,
            blocks,
            after,
            test,
        } => handle_add(title, blocks.as_deref(), after.as_deref(), test.as_deref()),
        Commands::Next { json } => handle_next(*json),
        Commands::List => handle_list(),
        Commands::Do { task } => handle_do(task),
        Commands::Check => handle_check(),
        Commands::Status => handle_status(),
    }
}

fn handle_init() -> Result<()> {
    Db::init()?;
    println!("{} Initialized .roadmap/state.db", "‚úì".green());
    Ok(())
}

fn handle_add(
    title: &str,
    blocks: Option<&str>,
    after: Option<&str>,
    test_cmd: Option<&str>,
) -> Result<()> {
    let conn = Db::connect()?;
    let repo = TaskRepo::new(conn);

    let slug = slugify(title);

    // Check for duplicate slug
    if repo.find_by_slug(&slug)?.is_some() {
        bail!("Task with slug '{slug}' already exists");
    }

    // Insert the task
    let task_id = if let Some(cmd) = test_cmd {
        repo.add_with_test(&slug, title, cmd)?
    } else {
        repo.add(&slug, title)?
    };

    println!("{} Added task [{}] {}", "‚úì".green(), slug.yellow(), title);

    // Handle dependencies
    let resolver = TaskResolver::new(repo.conn());

    // If --after is specified, create edge: after_task -> new_task
    if let Some(after_ref) = after {
        let after_task = resolver.resolve(after_ref)?;

        // Check for cycles
        let graph = TaskGraph::build(repo.conn())?;
        if graph.would_create_cycle(after_task.task.id, task_id) {
            bail!("Adding this dependency would create a cycle!");
        }

        repo.link(after_task.task.id, task_id)?;
        println!(
            "   {} [{}] blocks [{}]",
            "‚Üí".cyan(),
            after_task.task.slug,
            slug
        );
    }

    // If --blocks is specified, create edge: new_task -> blocks_task
    if let Some(blocks_ref) = blocks {
        let blocks_task = resolver.resolve(blocks_ref)?;

        // Check for cycles
        let graph = TaskGraph::build(repo.conn())?;
        if graph.would_create_cycle(task_id, blocks_task.task.id) {
            bail!("Adding this dependency would create a cycle!");
        }

        repo.link(task_id, blocks_task.task.id)?;
        println!(
            "   {} [{}] blocks [{}]",
            "‚Üí".cyan(),
            slug,
            blocks_task.task.slug
        );
    }

    Ok(())
}

fn handle_next(json: bool) -> Result<()> {
    let conn = Db::connect()?;
    let graph = TaskGraph::build(&conn)?;
    let critical_path = graph.get_critical_path();

    if json {
        let tasks: Vec<_> = critical_path
            .iter()
            .map(|t| {
                serde_json::json!({
                    "id": t.id,
                    "slug": t.slug,
                    "title": t.title,
                    "status": t.status.to_string(),
                    "test_cmd": t.test_cmd
                })
            })
            .collect();

        println!("{}", serde_json::to_string_pretty(&tasks)?);
        return Ok(());
    }

    println!("{} Next Actionable Tasks:", "üéØ".to_string().cyan());

    if critical_path.is_empty() {
        println!(
            "   {} All tasks completed or none defined.",
            "(empty)".dimmed()
        );
        return Ok(());
    }

    for task in critical_path {
        let status_icon = match task.status {
            TaskStatus::Pending => "‚óã".dimmed(),
            TaskStatus::Active => "‚óè".yellow(),
            TaskStatus::Done => "‚úì".green(),
            TaskStatus::Blocked => "‚äò".red(),
        };

        println!("   {} [{}] {}", status_icon, task.slug.yellow(), task.title);

        // Show what this task blocks
        let blocked = graph.get_blocked_by(task.id);
        if !blocked.is_empty() {
            let names: Vec<_> = blocked.iter().map(|t| t.slug.as_str()).collect();
            println!(
                "      {} {}",
                "‚îî‚îÄ blocks:".dimmed(),
                names.join(", ").dimmed()
            );
        }
    }

    Ok(())
}

fn handle_list() -> Result<()> {
    let conn = Db::connect()?;
    let repo = TaskRepo::new(conn);
    let tasks = repo.get_all()?;

    println!("{} All Tasks:", "üìã".to_string().cyan());

    if tasks.is_empty() {
        println!("   {} No tasks defined yet.", "(empty)".dimmed());
        return Ok(());
    }

    for task in tasks {
        let status_icon = match task.status {
            TaskStatus::Pending => "‚óã".dimmed(),
            TaskStatus::Active => "‚óè".yellow(),
            TaskStatus::Done => "‚úì".green(),
            TaskStatus::Blocked => "‚äò".red(),
        };

        let test_indicator = if task.test_cmd.is_some() { " üß™" } else { "" };

        println!(
            "   {} [{}] {} ({}){}",
            status_icon,
            task.slug.blue(),
            task.title,
            task.status.to_string().dimmed(),
            test_indicator
        );
    }

    Ok(())
}

fn handle_do(task_ref: &str) -> Result<()> {
    let conn = Db::connect()?;
    let resolver = TaskResolver::new(&conn);

    let result = resolver.resolve(task_ref)?;
    let task = &result.task;

    // Check if task is blocked
    let graph = TaskGraph::build(&conn)?;
    let blockers = graph.get_blockers(task.id);
    let active_blockers: Vec<_> = blockers
        .iter()
        .filter(|t| t.status != TaskStatus::Done)
        .collect();

    if !active_blockers.is_empty() {
        let names: Vec<_> = active_blockers.iter().map(|t| t.slug.as_str()).collect();
        bail!("Task [{}] is blocked by: {}", task.slug, names.join(", "));
    }

    // Set as active
    let repo = TaskRepo::new(conn);
    repo.update_status(task.id, TaskStatus::Active)?;
    repo.set_active_task(task.id)?;

    println!(
        "{} Now working on: [{}] {}",
        "‚óè".yellow(),
        task.slug.yellow(),
        task.title
    );

    if let Some(ref cmd) = task.test_cmd {
        println!("   {} {}", "verify:".dimmed(), cmd.dimmed());
    }

    Ok(())
}

fn handle_check() -> Result<()> {
    let conn = Db::connect()?;
    let repo = TaskRepo::new(conn);

    // Get active task
    let active_id = repo.get_active_task_id()?;
    let active_id = match active_id {
        Some(id) => id,
        None => bail!("No active task. Run `roadmap do <task>` first."),
    };

    let task = repo.find_by_id(active_id)?;
    let task = match task {
        Some(t) => t,
        None => bail!("Active task not found in database."),
    };

    println!(
        "{} Checking: [{}] {}",
        "üîç".to_string(),
        task.slug.yellow(),
        task.title
    );

    // Get verification command
    let test_cmd = match &task.test_cmd {
        Some(cmd) => cmd,
        None => {
            // No test command - allow manual completion
            println!("{} No verification command defined.", "‚ö†".yellow());
            println!("   Run with --force to mark complete, or add a test:");
            println!("   roadmap edit {} --test \"your_test_cmd\"", task.slug);
            return Ok(());
        }
    };

    println!("   {} {}", "running:".dimmed(), test_cmd);

    // Execute verification
    let runner = VerifyRunner::default_runner();
    let result = runner.verify(test_cmd)?;

    if result.passed() {
        // Mark as DONE
        repo.update_status(task.id, TaskStatus::Done)?;

        println!(
            "{} Verified! Task [{}] marked DONE ({:.2}s)",
            "‚úì".green(),
            task.slug.green(),
            result.duration.as_secs_f64()
        );

        // Show what's now unblocked
        let graph = TaskGraph::build(repo.conn())?;
        let unblocked = graph.get_critical_path();
        let newly_available: Vec<_> = unblocked.iter().filter(|t| t.id != task.id).collect();

        if !newly_available.is_empty() {
            println!("\n{} Now available:", "üéØ".to_string());
            for t in newly_available.iter().take(3) {
                println!("   ‚óã [{}] {}", t.slug.yellow(), t.title);
            }
        }
    } else {
        println!(
            "{} Verification failed. Task remains {}.",
            "‚úó".red(),
            "ACTIVE".yellow()
        );
    }

    Ok(())
}

fn handle_status() -> Result<()> {
    let conn = Db::connect()?;
    let repo = TaskRepo::new(conn);
    let graph = TaskGraph::build(repo.conn())?;

    let all_tasks = repo.get_all()?;
    let done_count = all_tasks
        .iter()
        .filter(|t| t.status == TaskStatus::Done)
        .count();
    let total = all_tasks.len();

    println!("{} Roadmap Status", "üìä".to_string().cyan());
    println!("   Tasks: {}/{} complete", done_count, total);
    println!(
        "   Graph: {} nodes, {} edges",
        graph.task_count(),
        graph.edge_count()
    );

    // Current focus
    if let Some(active_id) = repo.get_active_task_id()? {
        if let Some(task) = repo.find_by_id(active_id)? {
            println!(
                "\n{} Focus: [{}] {}",
                "‚óè".yellow(),
                task.slug.yellow(),
                task.title
            );
        }
    } else {
        println!("\n{} No active task", "‚óã".dimmed());
    }

    // Next up
    let critical = graph.get_critical_path();
    if !critical.is_empty() {
        println!("\n{} Next up:", "‚Üí".cyan());
        for task in critical.iter().take(3) {
            println!("   ‚óã [{}] {}", task.slug.dimmed(), task.title);
        }
    }

    Ok(())
}

#__SLOPCHOP_END__#

