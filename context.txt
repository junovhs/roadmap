#__SLOPCHOP_FILE__# Cargo.toml
[package]
name = "roadmap"
version = "0.3.1"
edition = "2021"
description = "A proof-carrying roadmap: DAG of claims with derived truth."

[dependencies]
rusqlite = { version = "0.32", features = ["bundled"] }
clap = { version = "4.5", features = ["derive"] }
petgraph = "0.6"
colored = "2.1"
thiserror = "2.0"
anyhow = "1.0"
chrono = "0.4"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

[dev-dependencies]
tempfile = "3.10"
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# DOCS/DEFINITION_OF_SUCCESS.md
# Definition of Success: Project Cortex (Roadmap)

> **Thesis:** Roadmap is a proof-carrying roadmap - a DAG of claims whose completion is operationally trustworthy.

---

## 1. Core Philosophy

### The Differentiator

| Tool | Question it Answers |
|------|---------------------|
| Beads | "What should we do next, and how do we remember it?" |
| **Roadmap** | "What is true right now, and what truth is missing?" |

### DONE as Derived Fact

"DONE" is not a flag someone sets. It is a **computed state** based on:

1. A verifier exists (`prove_cmd`)
2. The verifier passed (exit code 0)
3. The proof is still valid for the current `HEAD` (Smart Decay)

---

## 2. Version Milestones

### v0.1.0 ‚úÖ - MVP
Scaffold, CLI, DAG enforcement.

### v0.1.1 ‚úÖ - Ship-Worthy
Transactions, WAL mode, Fuzzy resolution.

### v0.2.0 ‚úÖ - Derived Truth
- [x] **Audit Log**: Append-only proof history (`proofs` table)
- [x] **Truth Decay**: SHA-based staleness checks
- [x] **Visibility**: `why`, `stale`, and `history` commands

### v0.3.0 ‚úÖ - Contextual Intelligence
- [x] **Smart Decay**: Scoped invalidation using `git diff`
- [x] **RepoContext**: Efficient git operations
- [x] **Strict Mode**: `check` fails on dirty repo

### v0.4.0 - "The Agent Protocol"
Making Roadmap the standard interface for AI coding agents.

- [ ] **Structured Output**: Full JSON schema for all read commands
- [ ] **Agent Handshake**: Protocol for agents to "sign" their work
- [ ] **Remote Sync**: Database replication via Git LFS or similar

---

## 3. Technical Constraints

### Performance
- Cold start: < 15ms
- Graph traversal (1000 nodes): < 5ms
- Memory: < 10MB RSS

### Integrity
- SQLite strict transactions
- Cycle rejection at insertion time
- **Law of Hygiene**: No proofs on dirty repos

### SlopChop Compliance
- Max file tokens: 2000
- Max cyclomatic complexity: 8
- Max nesting depth: 3

---

## 4. Sign-off Criteria

### v0.3.0 ships when:
1. `roadmap check` fails on uncommitted changes.
2. Changing a scoped file marks the task STALE.
3. Changing an unscoped file does NOT mark scoped tasks STALE.

---

*"What is true, right now, in this repo?"*
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# README.md
# Roadmap (Project Cortex)

> **A proof-carrying roadmap.**
> A DAG of claims whose completion is operationally trustworthy.
>
> Said simply: it's a roadmap for your project that updates itself based on what is and isn't true.

---

## The Workflow: From Zero to Truth

Roadmap isn't a todo list; it's a state machine. Here is the exact lifecycle of a project, from empty directory to verified truth.

### 1. Define the Reality (Setup)
You define the work and the topology (dependencies). This replaces writing a `TODO.md` or filling out JIRA tickets.

> **üí° AI Pro-Tip:** Writing these commands manually can be verbose. Just paste your `SPEC.md` or feature list into an LLM and say: *"Generate the `roadmap add` commands for this, including dependencies and file scopes."* It handles the graph topology perfectly.

```bash
roadmap init

# Define the goal, the test that proves it, and the files it touches.
roadmap add "Database Engine" \
    --test "cargo test db_core" \
    --scope "src/db/**"

# Define the dependent feature. This is BLOCKED until DB is done.
roadmap add "User Auth" \
    --after "database-engine" \
    --test "cargo test auth" \
    --scope "src/auth/**"
```

### 2. The Daily Loop (Flow)
You don't guess what to work on. You ask the graph.

```bash
roadmap next
# Output: [database-engine] (User Auth is hidden because it's blocked)

roadmap do database-engine
# Locks this task as your active context.
```

### 3. The Handshake (Hygiene)
You write the code. Tests pass.
**Crucial Step:** Roadmap adheres to the **Law of Hygiene**. It refuses to verify a "dirty" working tree. Truth is a property of a *Commit*, not a work-in-progress.

```bash
git add .
git commit -m "feat: db works"

roadmap check
# Runs 'cargo test db_core'.
# If Pass: Records {SHA, Timestamp, ExitCode} to SQLite.
# 'User Auth' is now unblocked.
```

### 4. The Payoff (Truth Decay)
Three weeks later, you change a file in `src/db/lib.rs`.
Roadmap detects that `HEAD` moved and the diff touches the scope of "Database Engine".

```bash
roadmap status
# Output: [database-engine] -> STALE (yellow)
```

The system forces you to re-verify the foundation before you build more on top. This prevents the "Rot" that plagues standard todo lists.

---

## Philosophy

### The Core Difference

| Tool | Model | "Done" means... |
|------|-------|-----------------|
| JIRA, Trello, TODO.md | Logger | "Someone said so" |
| **Roadmap** | State Machine | "The verifier passed on this Commit" |

### 1. Derived Truth
Roadmap trusts the **Proof Audit Log**, not your memory.
- **PROVEN:** The verification passed on the *current* Git commit.
- **STALE:** The verification passed previously, but the code has changed since then.
- **BROKEN:** The verification command failed.

### 2. Smart Decay (Contextual Intelligence)
Codebases change. Roadmap knows *what* changed.
- **Global Decay:** If a task has no scope, *any* commit marks it STALE. (Safe default).
- **Smart Decay:** If a task has a `--scope` (e.g., `src/auth/**`), it stays PROVEN unless the changes touch those files.

---

## Threat Model & Non-Goals

**Roadmap is a local developer tool, not a cryptographic ledger.**

1.  **Evidence, not Proofs:** We use the term "Proof" colloquially. Technically, we store *Evidence* (a record that a command exited 0). We do not provide cryptographic signatures or reproducible builds.
2.  **Arbitrary Execution:** `roadmap check` executes shell commands defined in the database.
    *   **Do not** initialize Roadmap from an untrusted database source.
    *   **Do not** run `roadmap check` on a shared repository without auditing the `test_cmd` fields first.
3.  **Local Trust:** The system trusts that the local `git` command is not compromised and that the SQLite file has not been tampered with by other processes.

---

## Commands

| Command | Description |
|---------|-------------|
| `roadmap add` | Add claim with `--after`, `--test`, `--scope` |
| `roadmap next` | Show frontier (unblocked, unproven) |
| `roadmap do` | Set active claim (validates deps) |
| `roadmap check` | Run `prove_cmd`, store proof, update status |
| `roadmap why` | Explain why a task is Stale/Proven + Audit Log |
| `roadmap stale` | **Debt Radar:** Scan for invalidated proofs |
| `roadmap history` | Stream chronological verification events |
| `roadmap status` | Overview dashboard |

---

## Development Status

### v0.1.0 ‚úÖ - Core Implementation
- Database engine (SQLite)
- Graph engine (petgraph, cycle detection)

### v0.2.0 ‚úÖ - Derived Truth
- Audit Log (append-only proofs)
- SHA-based Global Staleness
- `why`, `stale`, and `history` commands

### v0.3.0 ‚úÖ - Contextual Intelligence
- **Smart Decay**: Scoped invalidation using `git diff`
- **RepoContext**: Context-aware status derivation
- **Strict Mode**: Enforced hygiene (no dirty checks)

---

*"What is true, right now, in this repo?"*
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# slopchop.toml
[rules]
max_file_tokens = 2000
max_cyclomatic_complexity = 8
max_nesting_depth = 3
max_function_args = 5
max_function_words = 5
ignore_naming_on = [
    "tests",
    "spec",
]
ignore_tokens_on = [
    "README.md",
    "lock",
]

[preferences]
theme = "Cyberpunk"
auto_copy = true
auto_format = false
auto_commit = false
commit_prefix = "AI: "
allow_dirty_git = false
system_bell = false
backup_retention = 5
progress_bars = true
require_plan = false

[commands]
check = [
    "cargo clippy --all-targets -- -D warnings -W clippy::pedantic",
    "cargo test",
]
fix = ["cargo fmt"]

#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/engine/context.rs
//! Repository Context: The oracle for repo state and file changes.

use anyhow::Result;
use std::process::Command;

/// Encapsulates the state of the git repository.
///
/// Handles caching `git diff` operations to determine scoped staleness efficiently.
pub struct RepoContext {
    pub head_sha: String,
    pub is_dirty: bool,
}

impl RepoContext {
    /// Captures the current repository state.
    ///
    /// # Errors
    /// Returns error if git execution fails.
    pub fn new() -> Result<Self> {
        let head_sha = get_git_sha();
        let is_dirty = check_if_dirty();
        Ok(Self { head_sha, is_dirty })
    }

    /// Returns the current HEAD SHA.
    #[must_use]
    pub fn head_sha(&self) -> &str {
        &self.head_sha
    }

    /// Checks if files matching the given scopes have changed between `since_sha` and HEAD.
    ///
    /// # Returns
    /// - `true` if changes are detected or if git fails (safe default).
    /// - `false` if `git diff --quiet` returns 0 (no changes).
    #[must_use]
    pub fn has_changes(&self, since_sha: &str, scopes: &[String]) -> bool {
        if scopes.is_empty() {
            return true; // No scope implies global sensitivity
        }

        // If SHAs match, obviously no changes.
        if since_sha == self.head_sha {
            return false;
        }

        // git diff --quiet <old> HEAD -- <paths...>
        // Returns 0 if no changes, 1 if changes.
        let mut cmd = Command::new("git");
        cmd.arg("diff")
           .arg("--quiet")
           .arg(since_sha)
           .arg("HEAD")
           .arg("--");
        
        for scope in scopes {
            cmd.arg(scope);
        }

        match cmd.status() {
            Ok(status) => !status.success(), // success (0) means NO changes
            Err(_) => true, // If git fails, assume the worst (Stale)
        }
    }
}

fn get_git_sha() -> String {
    Command::new("git")
        .args(["rev-parse", "HEAD"])
        .output()
        .ok()
        .and_then(|o| String::from_utf8(o.stdout).ok())
        .map_or_else(|| "unknown".to_string(), |s| s.trim().to_string())
}

fn check_if_dirty() -> bool {
    // git status --porcelain
    // Prints nothing if clean. Prints lines if dirty.
    // If git command fails, we default to true (safe side).
    match Command::new("git")
        .arg("status")
        .arg("--porcelain")
        .output()
    {
        Ok(o) => !o.stdout.is_empty(),
        Err(_) => true,
    }
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/engine/db.rs
//! Database initialization and connection management.

use anyhow::{Context, Result};
use rusqlite::Connection;
use std::fs;
use std::path::Path;

const DB_DIR: &str = ".roadmap";
const DB_FILE: &str = "state.db";

pub struct Db;

impl Db {
    /// Initializes the .roadmap directory and `SQLite` database schema.
    ///
    /// # Errors
    /// Returns an error if the directory cannot be created or the database
    /// initialization fails.
    pub fn init() -> Result<()> {
        if !Path::new(DB_DIR).exists() {
            fs::create_dir(DB_DIR).context("Failed to create .roadmap directory")?;
        }

        let db_path = Path::new(DB_DIR).join(DB_FILE);
        let conn = Connection::open(db_path).context("Failed to open database")?;

        Self::configure(&conn)?;
        Self::migrate(&conn)?;

        Ok(())
    }

    /// Connects to an existing database and ensures schema is up-to-date.
    ///
    /// # Errors
    /// Returns an error if the database file does not exist or cannot be opened.
    pub fn connect() -> Result<Connection> {
        let db_path = Path::new(DB_DIR).join(DB_FILE);
        if !db_path.exists() {
            anyhow::bail!("Roadmap not initialized. Run `roadmap init` first.");
        }
        let conn = Connection::open(db_path).context("Failed to open database")?;
        
        Self::configure(&conn)?;
        Self::migrate(&conn)?;
        
        Ok(conn)
    }

    /// Configures `SQLite` connection for integrity and concurrency.
    fn configure(conn: &Connection) -> Result<()> {
        conn.execute_batch(
            "PRAGMA foreign_keys = ON;
             PRAGMA journal_mode = WAL;
             PRAGMA busy_timeout = 5000;",
        )?;
        Ok(())
    }

    /// Applies schema migrations.
    fn migrate(conn: &Connection) -> Result<()> {
        conn.execute(
            "CREATE TABLE IF NOT EXISTS tasks (
                id INTEGER PRIMARY KEY,
                slug TEXT UNIQUE NOT NULL,
                title TEXT NOT NULL,
                status TEXT NOT NULL,
                test_cmd TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )",
            [],
        )?;

        conn.execute(
            "CREATE TABLE IF NOT EXISTS task_scopes (
                id INTEGER PRIMARY KEY,
                task_id INTEGER NOT NULL,
                glob TEXT NOT NULL,
                FOREIGN KEY(task_id) REFERENCES tasks(id)
            )",
            [],
        )?;

        conn.execute(
            "CREATE TABLE IF NOT EXISTS proofs (
                id INTEGER PRIMARY KEY,
                task_id INTEGER NOT NULL,
                cmd TEXT NOT NULL,
                exit_code INTEGER NOT NULL,
                git_sha TEXT NOT NULL,
                duration_ms INTEGER NOT NULL,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                attested_reason TEXT,
                FOREIGN KEY(task_id) REFERENCES tasks(id)
            )",
            [],
        )?;

        // Migration: Add stdout/stderr to proofs if missing (v0.3.1)
        let has_logs: bool = conn
            .prepare("SELECT stdout FROM proofs LIMIT 1")
            .is_ok();
        
        if !has_logs {
            // We use default empty string for existing records
            let _ = conn.execute("ALTER TABLE proofs ADD COLUMN stdout TEXT DEFAULT ''", []);
            let _ = conn.execute("ALTER TABLE proofs ADD COLUMN stderr TEXT DEFAULT ''", []);
        }

        conn.execute(
            "CREATE TABLE IF NOT EXISTS dependencies (
                blocker_id INTEGER,
                blocked_id INTEGER,
                PRIMARY KEY (blocker_id, blocked_id),
                FOREIGN KEY(blocker_id) REFERENCES tasks(id),
                FOREIGN KEY(blocked_id) REFERENCES tasks(id)
            )",
            [],
        )?;

        conn.execute(
            "CREATE TABLE IF NOT EXISTS state (
                key TEXT PRIMARY KEY,
                value TEXT
            )",
            [],
        )?;

        Ok(())
    }
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/engine/graph.rs
//! Graph Engine: In-memory DAG representation.

use super::context::RepoContext;
use super::repo::TaskRepo;
use super::types::{DerivedStatus, Task};
use anyhow::Result;
use petgraph::algo::is_cyclic_directed;
use petgraph::graphmap::DiGraphMap;
use rusqlite::Connection;
use std::collections::HashMap;

pub struct TaskGraph {
    graph: DiGraphMap<i64, ()>,
    tasks: HashMap<i64, Task>,
    context: RepoContext,
}

impl TaskGraph {
    /// Builds the dependency graph from the database.
    ///
    /// # Errors
    /// Returns an error if the database query fails or git context cannot be loaded.
    pub fn build(conn: &Connection) -> Result<Self> {
        let mut graph = DiGraphMap::new();
        let repo = TaskRepo::new(conn);
        let tasks = repo.get_all()?;
        let mut task_map = HashMap::new();

        for t in tasks {
            graph.add_node(t.id);
            task_map.insert(t.id, t);
        }

        let mut stmt = conn.prepare("SELECT blocker_id, blocked_id FROM dependencies")?;
        let edges = stmt.query_map([], |r| Ok((r.get::<_, i64>(0)?, r.get::<_, i64>(1)?)))?;
        for e in edges {
            let (src, dst) = e?;
            graph.add_edge(src, dst, ());
        }

        Ok(Self {
            graph,
            tasks: task_map,
            context: RepoContext::new()?,
        })
    }

    /// Returns tasks that are unblocked and require work (Unproven, Stale, or Broken).
    #[must_use]
    pub fn get_frontier(&self) -> Vec<&Task> {
        let mut frontier: Vec<_> = self
            .tasks
            .values()
            .filter(|t| {
                let status = t.derive_status(&self.context);
                status.is_actionable()
            })
            .filter(|t| !self.is_blocked(t.id))
            .collect();

        frontier.sort_by_key(|t| t.id);
        frontier
    }

    /// Checks if a task is blocked by any dependency that isn't Proven or Attested.
    fn is_blocked(&self, id: i64) -> bool {
        self.graph
            .neighbors_directed(id, petgraph::Direction::Incoming)
            .any(|sid| {
                let Some(task) = self.tasks.get(&sid) else {
                    return false;
                };
                let status = task.derive_status(&self.context);
                !matches!(status, DerivedStatus::Proven | DerivedStatus::Attested)
            })
    }

    /// Detects if adding an edge would create a cycle.
    #[must_use]
    pub fn would_create_cycle(&self, from: i64, to: i64) -> bool {
        let mut test = self.graph.clone();
        test.add_edge(from, to, ());
        is_cyclic_directed(&test)
    }

    /// Returns the current git HEAD SHA.
    #[must_use]
    pub fn head_sha(&self) -> &str {
        self.context.head_sha()
    }

    /// Gets tasks blocked by the given ID.
    #[must_use]
    pub fn get_blocked_by(&self, id: i64) -> Vec<&Task> {
        self.graph
            .neighbors_directed(id, petgraph::Direction::Outgoing)
            .filter_map(|i| self.tasks.get(&i))
            .collect()
    }

    /// Gets tasks that block the given ID.
    #[must_use]
    pub fn get_blockers(&self, id: i64) -> Vec<&Task> {
        self.graph
            .neighbors_directed(id, petgraph::Direction::Incoming)
            .filter_map(|i| self.tasks.get(&i))
            .collect()
    }
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/engine/mod.rs
//! Core engine modules for roadmap.

pub mod context;
pub mod db;
pub mod graph;
pub mod repo;
pub mod resolver;
pub mod runner;
pub mod state;
pub mod types;
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/engine/repo.rs
//! Repository module.
//!
//! Splits responsibilities into Tasks (structure) and Proofs (verification).

pub mod proofs;
pub mod tasks;

pub use proofs::ProofRepo;
pub use tasks::{TaskRepo, TASK_SELECT};
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/engine/repo/proofs.rs
//! Proof Repository: Handles verification evidence and audit logs.

use crate::engine::types::Proof;
use anyhow::Result;
use rusqlite::{params, Connection, OptionalExtension};

pub struct ProofRepo<'a> {
    conn: &'a Connection,
}

impl<'a> ProofRepo<'a> {
    /// Creates a new proof repository instance.
    #[must_use]
    pub fn new(conn: &'a Connection) -> Self {
        Self { conn }
    }

    /// Records a verification proof for a task.
    ///
    /// # Errors
    /// Returns an error if the proof cannot be saved.
    pub fn save(&self, task_id: i64, proof: &Proof) -> Result<()> {
        self.conn.execute(
            "INSERT INTO proofs (task_id, cmd, exit_code, git_sha, duration_ms, attested_reason, stdout, stderr) 
             VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8)",
            params![
                task_id,
                proof.cmd,
                proof.exit_code,
                proof.git_sha,
                proof.duration_ms,
                proof.attested_reason,
                proof.stdout,
                proof.stderr
            ],
        )?;
        Ok(())
    }

    /// Gets the most recent proof recorded for a task.
    ///
    /// # Errors
    /// Returns a `rusqlite` error if query logic fails.
    pub fn get_latest(&self, task_id: i64) -> rusqlite::Result<Option<Proof>> {
        self.conn
            .query_row(
                "SELECT cmd, exit_code, git_sha, duration_ms, timestamp, attested_reason, stdout, stderr 
                 FROM proofs WHERE task_id = ?1 ORDER BY timestamp DESC LIMIT 1",
                params![task_id],
                |row| {
                    Ok(Proof {
                        cmd: row.get(0)?,
                        exit_code: row.get(1)?,
                        git_sha: row.get(2)?,
                        duration_ms: row.get(3)?,
                        timestamp: row.get(4)?,
                        attested_reason: row.get(5)?,
                        stdout: row.get(6)?,
                        stderr: row.get(7)?,
                    })
                },
            )
            .optional()
    }

    /// Retrieves the full history of proofs for a task.
    ///
    /// # Errors
    /// Returns an error if the query fails.
    pub fn get_history(&self, task_id: i64) -> Result<Vec<Proof>> {
        let mut stmt = self.conn.prepare(
            "SELECT cmd, exit_code, git_sha, duration_ms, timestamp, attested_reason, stdout, stderr 
             FROM proofs WHERE task_id = ?1 ORDER BY timestamp DESC",
        )?;
        let rows = stmt.query_map(params![task_id], |row| {
            Ok(Proof {
                cmd: row.get(0)?,
                exit_code: row.get(1)?,
                git_sha: row.get(2)?,
                duration_ms: row.get(3)?,
                timestamp: row.get(4)?,
                attested_reason: row.get(5)?,
                stdout: row.get(6)?,
                stderr: row.get(7)?,
            })
        })?;

        let mut proofs = Vec::new();
        for p in rows {
            proofs.push(p?);
        }
        Ok(proofs)
    }

    /// Retrieves global proof history joined with task slugs.
    ///
    /// # Errors
    /// Returns an error if the query fails.
    pub fn get_global_history(&self, limit: usize) -> Result<Vec<(String, Proof)>> {
        let mut stmt = self.conn.prepare(
            "SELECT t.slug, p.cmd, p.exit_code, p.git_sha, p.duration_ms, p.timestamp, p.attested_reason, p.stdout, p.stderr 
             FROM proofs p 
             JOIN tasks t ON p.task_id = t.id 
             ORDER BY p.timestamp DESC 
             LIMIT ?1"
        )?;

        let rows = stmt.query_map(params![limit], |row| {
            let slug: String = row.get(0)?;
            let proof = Proof {
                cmd: row.get(1)?,
                exit_code: row.get(2)?,
                git_sha: row.get(3)?,
                duration_ms: row.get(4)?,
                timestamp: row.get(5)?,
                attested_reason: row.get(6)?,
                stdout: row.get(7)?,
                stderr: row.get(8)?,
            };
            Ok((slug, proof))
        })?;

        let mut history = Vec::new();
        for item in rows {
            history.push(item?);
        }
        Ok(history)
    }
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/engine/repo/tasks.rs
//! Task Repository: Core Task operations, Scopes, and State.

use super::proofs::ProofRepo;
use crate::engine::types::{Task, TaskStatus};
use anyhow::{Context, Result};
use rusqlite::{params, Connection, OptionalExtension};

pub const TASK_SELECT: &str = "SELECT id, slug, title, status, test_cmd, created_at FROM tasks";

pub struct TaskRepo<'a> {
    conn: &'a Connection,
}

impl<'a> TaskRepo<'a> {
    /// Creates a new repository instance borrowing the connection.
    #[must_use]
    pub fn new(conn: &'a Connection) -> Self {
        Self { conn }
    }

    /// Returns the underlying database connection.
    #[must_use]
    pub fn conn(&self) -> &Connection {
        self.conn
    }

    /// Adds a new task to the database.
    ///
    /// # Errors
    /// Returns an error if the insertion fails.
    pub fn add(&self, slug: &str, title: &str, test_cmd: Option<&str>) -> Result<i64> {
        self.conn.execute(
            "INSERT INTO tasks (slug, title, status, test_cmd) VALUES (?1, ?2, ?3, ?4)",
            params![slug, title, TaskStatus::Pending.to_string(), test_cmd],
        )?;
        Ok(self.conn.last_insert_rowid())
    }

    /// Associates a file glob scope with a task.
    ///
    /// # Errors
    /// Returns an error if insertion fails.
    pub fn add_scope(&self, task_id: i64, glob: &str) -> Result<()> {
        self.conn.execute(
            "INSERT INTO task_scopes (task_id, glob) VALUES (?1, ?2)",
            params![task_id, glob],
        )?;
        Ok(())
    }

    /// Creates a dependency link between two tasks.
    ///
    /// # Errors
    /// Returns an error if the link cannot be created.
    pub fn link(&self, from_id: i64, to_id: i64) -> Result<()> {
        self.conn.execute(
            "INSERT OR IGNORE INTO dependencies (blocker_id, blocked_id) VALUES (?1, ?2)",
            params![from_id, to_id],
        )?;
        Ok(())
    }

    /// Retrieves all tasks from the database.
    ///
    /// # Errors
    /// Returns an error if the query fails.
    pub fn get_all(&self) -> Result<Vec<Task>> {
        let mut stmt = self.conn.prepare(TASK_SELECT)?;
        let rows = stmt.query_map([], |r| self.row_to_task(r))?;
        let mut tasks = Vec::new();
        for task in rows {
            tasks.push(task?);
        }
        Ok(tasks)
    }

    /// Finds a task by its slug (case-insensitive).
    ///
    /// # Errors
    /// Returns an error if the query fails.
    pub fn find_by_slug(&self, slug: &str) -> Result<Option<Task>> {
        let sql = format!("{TASK_SELECT} WHERE LOWER(slug) = LOWER(?1)");
        self.conn
            .query_row(&sql, params![slug], |r| self.row_to_task(r))
            .optional()
            .context("Search by slug failed")
    }

    /// Finds a task by its internal ID.
    ///
    /// # Errors
    /// Returns an error if the query fails.
    pub fn find_by_id(&self, id: i64) -> Result<Option<Task>> {
        let sql = format!("{TASK_SELECT} WHERE id = ?1");
        self.conn
            .query_row(&sql, params![id], |r| self.row_to_task(r))
            .optional()
            .context("Search by ID failed")
    }

    /// Retrieves scopes associated with a task.
    ///
    /// # Errors
    /// Returns a `rusqlite` error if query logic fails.
    pub fn get_scopes(&self, task_id: i64) -> rusqlite::Result<Vec<String>> {
        let mut stmt = self
            .conn
            .prepare("SELECT glob FROM task_scopes WHERE task_id = ?1")?;
        let rows = stmt.query_map(params![task_id], |row| row.get(0))?;

        let mut scopes = Vec::new();
        for r in rows {
            scopes.push(r?);
        }
        Ok(scopes)
    }

    /// Sets the active task in global state.
    ///
    /// # Errors
    /// Returns an error if the state cannot be updated.
    pub fn set_active_task(&self, task_id: i64) -> Result<()> {
        self.conn.execute(
            "INSERT OR REPLACE INTO state (key, value) VALUES ('active_task', ?1)",
            params![task_id.to_string()],
        )?;
        Ok(())
    }

    /// Retrieves the ID of the currently active task.
    ///
    /// # Errors
    /// Returns an error if the state query fails.
    pub fn get_active_task_id(&self) -> Result<Option<i64>> {
        let res: Option<String> = self
            .conn
            .query_row(
                "SELECT value FROM state WHERE key = 'active_task'",
                [],
                |r| r.get(0),
            )
            .optional()?;
        Ok(res.and_then(|s| s.parse().ok()))
    }

    /// Updates the cached status column of a task.
    ///
    /// # Errors
    /// Returns an error if the update fails.
    pub fn update_status(&self, id: i64, status: TaskStatus) -> Result<()> {
        self.conn.execute(
            "UPDATE tasks SET status = ?1 WHERE id = ?2",
            params![status.to_string(), id],
        )?;
        Ok(())
    }

    /// Converts a database row to a Task object.
    ///
    /// # Errors
    /// Returns a `rusqlite` error if data conversion fails.
    pub fn row_to_task(&self, row: &rusqlite::Row) -> rusqlite::Result<Task> {
        let id: i64 = row.get(0)?;
        let proof_repo = ProofRepo::new(self.conn);
        let proof = proof_repo.get_latest(id)?;
        let scopes = self.get_scopes(id)?;

        Ok(Task {
            id,
            slug: row.get(1)?,
            title: row.get(2)?,
            status: TaskStatus::from(row.get::<_, String>(3)?),
            test_cmd: row.get(4)?,
            created_at: row.get(5)?,
            proof,
            scopes,
        })
    }
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/engine/resolver.rs
//! Fuzzy Task Resolver: Matches human queries to Task IDs.

use super::repo::{TaskRepo, TASK_SELECT};
use super::types::Task;
use anyhow::{bail, Result};
use rusqlite::{params, Connection, OptionalExtension};
use std::collections::HashSet;

pub struct ResolveResult {
    pub task: Task,
    pub confidence: f64,
}

pub struct TaskResolver<'a> {
    repo: TaskRepo<'a>,
    conn: &'a Connection,
    strict: bool,
}

impl<'a> TaskResolver<'a> {
    /// Creates a new resolver.
    #[must_use]
    pub fn new(conn: &'a Connection) -> Self {
        Self {
            repo: TaskRepo::new(conn),
            conn,
            strict: false,
        }
    }

    /// Creates a resolver in strict mode.
    #[must_use]
    pub fn strict(conn: &'a Connection) -> Self {
        Self {
            repo: TaskRepo::new(conn),
            conn,
            strict: true,
        }
    }

    /// Resolves a user query into a task.
    ///
    /// # Errors
    /// Returns an error if no match is found or the query is ambiguous.
    pub fn resolve(&self, query: &str) -> Result<ResolveResult> {
        if let Ok(id) = query.parse::<i64>() {
            if let Some(task) = self.repo.find_by_id(id)? {
                return Ok(ResolveResult {
                    task,
                    confidence: 1.0,
                });
            }
        }

        let sql = format!("{TASK_SELECT} WHERE LOWER(slug) = LOWER(?1)");
        let exact: Option<Task> = self
            .conn
            .query_row(&sql, params![query], |r| self.repo.row_to_task(r))
            .optional()?;

        if let Some(task) = exact {
            return Ok(ResolveResult {
                task,
                confidence: 1.0,
            });
        }

        if self.strict {
            bail!("No exact match for '{query}' in strict mode.");
        }
        self.fuzzy_resolve(query)
    }

    fn fuzzy_resolve(&self, query: &str) -> Result<ResolveResult> {
        let tasks = self.repo.get_all()?;
        let query_lower = query.to_lowercase();
        let words: Vec<_> = query_lower.split_whitespace().collect();

        let mut matches: Vec<_> = tasks
            .into_iter()
            .map(|t| (calculate_score(&t, &query_lower, &words), t))
            .filter(|(s, _)| *s > 0.3)
            .collect();

        matches.sort_by(|a, b| {
            b.0.partial_cmp(&a.0).unwrap_or(std::cmp::Ordering::Equal)
        });

        let (_, task) = matches
            .into_iter()
            .next()
            .ok_or_else(|| anyhow::anyhow!("No task matches '{query}'"))?;

        Ok(ResolveResult {
            task,
            confidence: 1.0,
        })
    }
}

/// Generates a slug from a title string.
#[must_use]
pub fn slugify(title: &str) -> String {
    title
        .to_lowercase()
        .chars()
        .map(|c| if c.is_alphanumeric() { c } else { '-' })
        .collect::<String>()
        .split('-')
        .filter(|s| !s.is_empty())
        .collect::<Vec<&str>>()
        .join("-")
}

/// Calculates a match score between a task and a query.
fn calculate_score(task: &Task, query: &str, query_words: &[&str]) -> f64 {
    let slug_lower = task.slug.to_lowercase();
    let title_lower = task.title.to_lowercase();

    let mut score = 0.0;

    if slug_lower.contains(query) {
        score += 0.8;
    }
    if title_lower.contains(query) {
        score += 0.7;
    }

    for word in query_words {
        if slug_lower.contains(word) {
            score += 0.3;
        }
        if title_lower.contains(word) {
            score += 0.25;
        }
    }

    if slug_lower.starts_with(query) {
        score += 0.5;
    }

    let slug_sim = string_similarity(&slug_lower, query);
    score += slug_sim * 0.4;

    score.min(1.0)
}

#[allow(clippy::cast_precision_loss)]
fn string_similarity(a: &str, b: &str) -> f64 {
    if a.is_empty() || b.is_empty() {
        return 0.0;
    }

    let a_chars: HashSet<char> = a.chars().collect();
    let b_chars: HashSet<char> = b.chars().collect();

    let intersection = a_chars.intersection(&b_chars).count();
    let union = a_chars.union(&b_chars).count();

    if union == 0 {
        return 0.0;
    }

    intersection as f64 / union as f64
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/engine/runner.rs
//! Verification Runner: Executes shell commands to verify task completion.
//!
//! The core principle: A task is not PROVEN until `verify_cmd` returns Exit Code 0.

use anyhow::{bail, Context, Result};
use std::process::{Command, Output, Stdio};
use std::time::{Duration, Instant};

/// Result of running a verification command.
#[derive(Debug)]
pub struct VerifyResult {
    pub success: bool,
    pub exit_code: Option<i32>,
    pub stdout: String,
    pub stderr: String,
    pub duration: Duration,
}

impl VerifyResult {
    /// Returns true if the verification passed (exit code 0).
    #[must_use]
    pub fn passed(&self) -> bool {
        self.success && self.exit_code == Some(0)
    }
}

/// Configuration for the verification runner.
#[derive(Debug, Clone)]
pub struct RunnerConfig {
    pub timeout_secs: u64,
    pub capture_output: bool,
    pub working_dir: Option<String>,
}

impl Default for RunnerConfig {
    fn default() -> Self {
        Self {
            timeout_secs: 300,
            capture_output: true,
            working_dir: None,
        }
    }
}

/// Executes verification commands.
pub struct VerifyRunner {
    config: RunnerConfig,
}

impl VerifyRunner {
    #[must_use]
    pub fn new(config: RunnerConfig) -> Self {
        Self { config }
    }

    #[must_use]
    pub fn default_runner() -> Self {
        Self::new(RunnerConfig::default())
    }

    /// Executes a shell command and returns the result.
    ///
    /// # Errors
    /// Returns error if command fails to spawn.
    pub fn run(&self, cmd: &str) -> Result<VerifyResult> {
        if cmd.trim().is_empty() {
            bail!("Empty verification command");
        }

        let start = Instant::now();
        let shell = if cfg!(target_os = "windows") {
            ("cmd", "/C")
        } else {
            ("sh", "-c")
        };

        let mut command = Command::new(shell.0);
        command.arg(shell.1).arg(cmd);

        if self.config.capture_output {
            command.stdout(Stdio::piped()).stderr(Stdio::piped());
        }

        if let Some(ref dir) = self.config.working_dir {
            command.current_dir(dir);
        }

        let output: Output = command
            .spawn()
            .context("Failed to spawn verification command")?
            .wait_with_output()
            .context("Failed to wait for command")?;

        let duration = start.elapsed();

        Ok(VerifyResult {
            success: output.status.success(),
            exit_code: output.status.code(),
            stdout: String::from_utf8_lossy(&output.stdout).to_string(),
            stderr: String::from_utf8_lossy(&output.stderr).to_string(),
            duration,
        })
    }

    /// Runs verification with user-friendly output on failure.
    ///
    /// # Errors
    /// Returns error if command fails to execute.
    pub fn verify(&self, cmd: &str) -> Result<VerifyResult> {
        let result = self.run(cmd)?;

        if !result.passed() {
            eprintln!("?ÔøΩ Verification Failed ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ");
            eprintln!("ÔøΩ Command: {cmd}");
            if let Some(code) = result.exit_code {
                eprintln!("ÔøΩ Exit Code: {code}");
            }
            if !result.stderr.is_empty() {
                eprintln!("ÔøΩ Stderr:");
                for line in result.stderr.lines().take(10) {
                    eprintln!("ÔøΩ   {line}");
                }
            }
            eprintln!("?ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ");
        }

        Ok(result)
    }
}

/// Gets current git HEAD SHA.
#[must_use]
pub fn get_git_sha() -> String {
    Command::new("git")
        .args(["rev-parse", "HEAD"])
        .output()
        .ok()
        .and_then(|o| String::from_utf8(o.stdout).ok())
        .map_or_else(|| "unknown".to_string(), |s| s.trim().to_string())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_simple_command() -> Result<()> {
        let runner = VerifyRunner::default_runner();
        let result = runner.run("echo hello")?;
        assert!(result.passed());
        assert!(result.stdout.contains("hello"));
        Ok(())
    }

    #[test]
    fn test_failing_command() -> Result<()> {
        let runner = VerifyRunner::default_runner();
        let result = runner.run("exit 1")?;
        assert!(!result.passed());
        assert_eq!(result.exit_code, Some(1));
        Ok(())
    }
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/engine/state.rs
//! Derived State Engine: Utilities for task state.

use super::context::RepoContext;
use super::types::{DerivedStatus, Task};

/// A task with its derived state pre-computed.
#[derive(Debug, Clone)]
pub struct TaskWithState {
    pub task: Task,
    pub state: DerivedStatus,
}

impl TaskWithState {
    #[must_use]
    pub fn new(task: Task, context: &RepoContext) -> Self {
        let state = task.derive_status(context);
        Self { task, state }
    }
}

/// Batch-derives state for multiple tasks.
#[must_use]
pub fn derive_all_states(tasks: Vec<Task>, context: &RepoContext) -> Vec<TaskWithState> {
    tasks
        .into_iter()
        .map(|task| TaskWithState::new(task, context))
        .collect()
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/engine/types.rs
//! Core types for the Roadmap system.

use super::context::RepoContext;
use serde::{Deserialize, Serialize};
use std::fmt;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum TaskStatus {
    Pending,
    Active,
    Done,
    Blocked,
    Attested,
}

impl fmt::Display for TaskStatus {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Pending => write!(f, "PENDING"),
            Self::Active => write!(f, "ACTIVE"),
            Self::Done => write!(f, "DONE"),
            Self::Blocked => write!(f, "BLOCKED"),
            Self::Attested => write!(f, "ATTESTED"),
        }
    }
}

impl From<String> for TaskStatus {
    fn from(s: String) -> Self {
        match s.as_str() {
            "ACTIVE" => Self::Active,
            "DONE" => Self::Done,
            "BLOCKED" => Self::Blocked,
            "ATTESTED" => Self::Attested,
            _ => Self::Pending,
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DerivedStatus {
    Unproven,
    Proven,
    Stale,
    Broken,
    Attested,
}

impl DerivedStatus {
    /// Returns the UI color name associated with this status.
    #[must_use]
    pub fn color_hint(&self) -> &'static str {
        match self {
            Self::Proven => "green",
            Self::Stale => "yellow",
            Self::Broken => "red",
            Self::Unproven => "dimmed",
            Self::Attested => "blue",
        }
    }

    /// Returns true if the task requires attention.
    #[must_use]
    pub fn is_actionable(&self) -> bool {
        matches!(self, Self::Unproven | Self::Stale | Self::Broken)
    }

    /// Returns true if the task fulfills its role as a dependency.
    #[must_use]
    pub fn satisfies_dependency(&self) -> bool {
        matches!(self, Self::Proven | Self::Attested)
    }
}

impl fmt::Display for DerivedStatus {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{self:?}")
    }
}

#[derive(Debug, Clone, Serialize)]
pub struct Task {
    pub id: i64,
    pub slug: String,
    pub title: String,
    pub status: TaskStatus,
    pub test_cmd: Option<String>,
    pub created_at: String,
    pub proof: Option<Proof>,
    pub scopes: Vec<String>,
}

impl Task {
    /// Computes the derived truth of the task based on proof history and repo context.
    #[must_use]
    pub fn derive_status(&self, context: &RepoContext) -> DerivedStatus {
        let Some(proof) = &self.proof else {
            return DerivedStatus::Unproven;
        };

        if proof.attested_reason.is_some() {
            return DerivedStatus::Attested;
        }

        if proof.exit_code != 0 {
            return DerivedStatus::Broken;
        }

        if !sha_matches(&proof.git_sha, context.head_sha()) {
            // Global mismatch. Check scopes for smart decay.
            if self.scopes.is_empty() {
                return DerivedStatus::Stale;
            }

            if context.has_changes(&proof.git_sha, &self.scopes) {
                return DerivedStatus::Stale;
            }
            // Scopes match (no changes in relevant files), so we preserve Proven status.
        }

        DerivedStatus::Proven
    }
}

/// Helper struct to group execution results for Proof creation.
pub struct ProofOutcome {
    pub exit_code: i32,
    pub duration_ms: u64,
    pub stdout: String,
    pub stderr: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Proof {
    pub cmd: String,
    pub exit_code: i32,
    pub git_sha: String,
    pub timestamp: String,
    pub duration_ms: u64,
    pub attested_reason: Option<String>,
    #[serde(default)]
    pub stdout: String,
    #[serde(default)]
    pub stderr: String,
}

impl Proof {
    /// Creates a new machine-verified proof with evidence logs.
    #[must_use]
    pub fn new(cmd: &str, git_sha: &str, outcome: ProofOutcome) -> Self {
        Self {
            cmd: cmd.to_string(),
            exit_code: outcome.exit_code,
            git_sha: git_sha.to_string(),
            timestamp: chrono::Utc::now().to_rfc3339(),
            duration_ms: outcome.duration_ms,
            attested_reason: None,
            stdout: outcome.stdout,
            stderr: outcome.stderr,
        }
    }

    /// Creates a new human-attested proof.
    #[must_use]
    pub fn attested(reason: &str, git_sha: &str) -> Self {
        Self {
            cmd: "--force".to_string(),
            exit_code: 0,
            git_sha: git_sha.to_string(),
            timestamp: chrono::Utc::now().to_rfc3339(),
            duration_ms: 0,
            attested_reason: Some(reason.to_string()),
            stdout: String::new(),
            stderr: String::new(),
        }
    }
}

/// Strict SHA matching. No fuzzy logic. Truth is precise.
fn sha_matches(stored: &str, current: &str) -> bool {
    if stored == "unknown" || current == "unknown" {
        return false; // Unknowns can't be trusted in strict mode
    }
    stored == current
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/handlers/add.rs
//! Handler for the `add` command.

use anyhow::{bail, Result};
use colored::Colorize;
use roadmap::engine::db::Db;
use roadmap::engine::graph::TaskGraph;
use roadmap::engine::repo::TaskRepo;
use roadmap::engine::resolver::{slugify, TaskResolver};

/// Handles adding a new task and its dependencies.
///
/// # Errors
/// Returns error if task exists, database is locked, or dependency creates a cycle.
pub fn handle(
    title: &str,
    blocks: Option<&str>,
    after: Option<&str>,
    test_cmd: Option<&str>,
    scopes: Option<Vec<String>>,
) -> Result<()> {
    let mut conn = Db::connect()?;
    let slug = slugify(title);

    let tx = conn.transaction()?;
    let repo = TaskRepo::new(&tx);

    if repo.find_by_slug(&slug)?.is_some() {
        bail!("Task with slug '{slug}' already exists");
    }

    let task_id = repo.add(&slug, title, test_cmd)?;

    if let Some(scope_list) = scopes {
        for scope in scope_list {
            repo.add_scope(task_id, &scope)?;
        }
    }

    if let Some(after_ref) = after {
        let resolver = TaskResolver::new(&tx);
        let after_task = resolver.resolve(after_ref)?;

        let graph = TaskGraph::build(&tx)?;
        if graph.would_create_cycle(after_task.task.id, task_id) {
            bail!("Adding this dependency would create a cycle!");
        }

        repo.link(after_task.task.id, task_id)?;
        println!(
            "   {} [{}] blocks [{}]",
            " ".cyan(),
            after_task.task.slug,
            slug
        );
    }

    if let Some(blocks_ref) = blocks {
        let resolver = TaskResolver::new(&tx);
        let blocks_task = resolver.resolve(blocks_ref)?;

        let graph = TaskGraph::build(&tx)?;
        if graph.would_create_cycle(task_id, blocks_task.task.id) {
            bail!("Adding this dependency would create a cycle!");
        }

        repo.link(task_id, blocks_task.task.id)?;
        println!(
            "   {} [{}] blocks [{}]",
            " ".cyan(),
            slug,
            blocks_task.task.slug
        );
    }

    tx.commit()?;
    println!("{} Added task [{}] {}", "‚úì".green(), slug.yellow(), title);
    Ok(())
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/handlers/check.rs
//! Handler for the `check` command.

use anyhow::{bail, Result};
use colored::Colorize;
use roadmap::engine::context::RepoContext;
use roadmap::engine::db::Db;
use roadmap::engine::graph::TaskGraph;
use roadmap::engine::repo::{ProofRepo, TaskRepo};
use roadmap::engine::runner::VerifyRunner;
use roadmap::engine::types::{Proof, ProofOutcome, Task, TaskStatus};

/// Runs verification for the active task.
///
/// # Errors
/// Returns error if no task is active or database fails.
pub fn handle(force: bool, reason: Option<&str>) -> Result<()> {
    let context = RepoContext::new()?;

    // LAW OF HYGIENE: The Dirty Lie
    if context.is_dirty {
        bail!(
            "Repository is dirty. You must commit your changes before verifying.\n   {}", 
            "Roadmap enforces strict hygiene: Truth is a property of a Commit, not a Worktree.".yellow()
        );
    }

    let conn = Db::connect()?;
    let repo = TaskRepo::new(&conn);

    let task = get_active_task(&repo)?;
    let derived = task.derive_status(&context);

    println!(
        "üîç Checking: [{}] {} ({})",
        task.slug.yellow(),
        task.title,
        derived.to_string().dimmed()
    );

    if force {
        return handle_force(&repo, &task, reason, context.head_sha());
    }

    let Some(test_cmd) = &task.test_cmd else {
        println!("{} No verification command defined.", "?".yellow());
        println!("   Use --force --reason \"...\" to mark as ATTESTED");
        return Ok(());
    };

    run_verification(&repo, &task, test_cmd, context.head_sha())
}

fn handle_force(
    repo: &TaskRepo<'_>,
    task: &Task,
    reason: Option<&str>,
    git_sha: &str,
) -> Result<()> {
    let reason = reason.unwrap_or("Manual attestation");
    let proof = Proof::attested(reason, git_sha);
    
    let proof_repo = ProofRepo::new(repo.conn());
    proof_repo.save(task.id, &proof)?;
    
    repo.update_status(task.id, TaskStatus::Attested)?;

    println!(
        "{} Task [{}] marked ATTESTED (not verified)",
        "!".yellow(),
        task.slug.yellow()
    );
    show_unblocked(repo, task.id)
}

fn get_active_task(repo: &TaskRepo<'_>) -> Result<Task> {
    let Some(active_id) = repo.get_active_task_id()? else {
        bail!("No active task. Run `roadmap do <task>` first.");
    };
    repo.find_by_id(active_id)?
        .ok_or_else(|| anyhow::anyhow!("Active task not found"))
}

fn run_verification(
    repo: &TaskRepo<'_>,
    task: &Task,
    test_cmd: &str,
    head_sha: &str,
) -> Result<()> {
    println!("   {} {}", "running:".dimmed(), test_cmd);
    let runner = VerifyRunner::default_runner();
    let result = runner.verify(test_cmd)?;

    if result.passed() {
        mark_proven(repo, task, test_cmd, &result, head_sha)
    } else {
        mark_broken(repo.conn(), task, test_cmd, &result, head_sha)
    }
}

#[allow(clippy::cast_possible_truncation)]
fn mark_proven(
    repo: &TaskRepo<'_>,
    task: &Task,
    cmd: &str,
    result: &roadmap::engine::runner::VerifyResult,
    git_sha: &str,
) -> Result<()> {
    let outcome = ProofOutcome {
        exit_code: result.exit_code.unwrap_or(0),
        duration_ms: result.duration.as_millis() as u64,
        stdout: result.stdout.clone(),
        stderr: result.stderr.clone(),
    };

    let proof = Proof::new(cmd, git_sha, outcome);
    let proof_repo = ProofRepo::new(repo.conn());
    proof_repo.save(task.id, &proof)?;
    
    repo.update_status(task.id, TaskStatus::Done)?;

    println!(
        "{} PROVEN! Task [{}] verified",
        "‚úì".green(),
        task.slug.green()
    );
    show_unblocked(repo, task.id)
}

#[allow(clippy::cast_possible_truncation)]
fn mark_broken(
    conn: &rusqlite::Connection,
    task: &Task,
    cmd: &str,
    result: &roadmap::engine::runner::VerifyResult,
    git_sha: &str,
) -> Result<()> {
    let outcome = ProofOutcome {
        exit_code: result.exit_code.unwrap_or(1),
        duration_ms: result.duration.as_millis() as u64,
        stdout: result.stdout.clone(),
        stderr: result.stderr.clone(),
    };

    let proof = Proof::new(cmd, git_sha, outcome);
    let proof_repo = ProofRepo::new(conn);
    proof_repo.save(task.id, &proof)?;

    println!(
        "{} BROKEN! Task [{}] verification failed",
        "‚úó".red(),
        task.slug.red()
    );
    Ok(())
}

fn show_unblocked(repo: &TaskRepo<'_>, done_id: i64) -> Result<()> {
    let graph = TaskGraph::build(repo.conn())?;
    let frontier = graph.get_frontier();
    
    let available: Vec<_> = frontier
        .into_iter()
        .filter(|t| t.id != done_id)
        .take(3)
        .collect();

    if !available.is_empty() {
        println!("\n‚ú® Now available:");
        for t in available {
            println!("   - [{}] {}", t.slug.yellow(), t.title);
        }
    }
    
    Ok(())
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/handlers/do_task.rs
//! Handler for the `do` command.

use anyhow::{bail, Result};
use colored::Colorize;
use roadmap::engine::context::RepoContext;
use roadmap::engine::db::Db;
use roadmap::engine::graph::TaskGraph;
use roadmap::engine::repo::TaskRepo;
use roadmap::engine::resolver::TaskResolver;
use roadmap::engine::types::{DerivedStatus, TaskStatus};

/// Sets a task as the active focus.
///
/// # Errors
/// Returns error if task is blocked or not found.
pub fn handle(task_ref: &str, strict: bool) -> Result<()> {
    let conn = Db::connect()?;
    let context = RepoContext::new()?;

    let resolver = if strict {
        TaskResolver::strict(&conn)
    } else {
        TaskResolver::new(&conn)
    };

    let result = resolver.resolve(task_ref)?;
    let task = &result.task;

    check_not_blocked(&conn, task, &context)?;

    let repo = TaskRepo::new(&conn);
    repo.update_status(task.id, TaskStatus::Active)?;
    repo.set_active_task(task.id)?;

    println!(
        "{} Now working on: [{}] {}",
        "‚Üí".yellow(),
        task.slug.yellow(),
        task.title
    );

    Ok(())
}

fn check_not_blocked(
    conn: &rusqlite::Connection,
    task: &roadmap::engine::types::Task,
    context: &RepoContext,
) -> Result<()> {
    let graph = TaskGraph::build(conn)?;
    let blockers = graph.get_blockers(task.id);

    let incomplete: Vec<_> = blockers
        .into_iter()
        .filter(|t| {
            let status = t.derive_status(context);
            !matches!(status, DerivedStatus::Proven | DerivedStatus::Attested)
        })
        .collect();

    if !incomplete.is_empty() {
        let names: Vec<_> = incomplete.iter().map(|t| t.slug.as_str()).collect();
        bail!("Task [{}] is blocked by: {}", task.slug, names.join(", "));
    }
    Ok(())
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/handlers/history.rs
//! Handler for the `history` command.

use anyhow::Result;
use colored::Colorize;
use roadmap::engine::db::Db;
use roadmap::engine::repo::ProofRepo;

/// Displays the global verification history.
///
/// # Errors
/// Returns error if database query fails.
pub fn handle(limit: usize) -> Result<()> {
    let conn = Db::connect()?;
    let proof_repo = ProofRepo::new(&conn);
    
    let history = proof_repo.get_global_history(limit)?;

    println!("{} Project History (last {})", "üìú".cyan(), limit);
    println!();

    if history.is_empty() {
        println!("   (No history recorded yet)");
        return Ok(());
    }

    for (slug, proof) in history {
        let timestamp = &proof.timestamp[..19.min(proof.timestamp.len())].replace('T', " ");
        
        let status = if proof.attested_reason.is_some() {
            "ATTESTED".blue()
        } else if proof.exit_code == 0 {
            "PASS    ".green()
        } else {
            "FAIL    ".red()
        };

        println!(
            "   {}  {}  {}  {}",
            timestamp.dimmed(),
            status,
            slug.bold(),
            format!("{}ms", proof.duration_ms).dimmed()
        );
    }

    Ok(())
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/handlers/init.rs
//! Handler for the `init` command.

use anyhow::Result;
use colored::Colorize;
use roadmap::engine::db::Db;

/// Initializes the roadmap repository.
///
/// # Errors
/// Returns error if database initialization fails.
pub fn handle() -> Result<()> {
    Db::init()?;
    println!("{} Initialized .roadmap/state.db", "‚úì".green());
    Ok(())
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/handlers/list.rs
//! Handler for the `list` command.

use anyhow::Result;
use colored::Colorize;
use roadmap::engine::context::RepoContext;
use roadmap::engine::db::Db;
use roadmap::engine::repo::TaskRepo;

/// Lists all tasks in the repository.
///
/// # Errors
/// Returns error if database query fails.
pub fn handle() -> Result<()> {
    let conn = Db::connect()?;
    let repo = TaskRepo::new(&conn);
    let tasks = repo.get_all()?;
    let context = RepoContext::new()?;

    println!("{} All Tasks:", "üìã".cyan());

    for task in tasks {
        let derived = task.derive_status(&context);
        println!(
            "   [{}] {} ({})",
            task.slug.blue(),
            task.title,
            derived.to_string().dimmed()
        );
    }
    Ok(())
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/handlers/mod.rs
pub mod add;
pub mod check;
pub mod do_task;
pub mod history;
pub mod init;
pub mod list;
pub mod next;
pub mod stale;
pub mod status;
pub mod why;
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/handlers/next.rs
//! Handler for the `next` command.

use anyhow::Result;
use colored::Colorize;
use roadmap::engine::context::RepoContext;
use roadmap::engine::db::Db;
use roadmap::engine::graph::TaskGraph;
use roadmap::engine::types::{DerivedStatus, Task};

/// Shows the frontier of actionable tasks.
///
/// # Errors
/// Returns error if database query fails.
pub fn handle(json: bool) -> Result<()> {
    let conn = Db::connect()?;
    let graph = TaskGraph::build(&conn)?;
    let frontier = graph.get_frontier();

    if json {
        return print_json(&frontier, graph.head_sha());
    }

    print_human(&frontier, &graph);
    Ok(())
}

fn print_json(tasks: &[&Task], head_sha: &str) -> Result<()> {
    // Reconstruct context from the provided SHA to derive status for JSON output.
    // This allows agents to see if a task is Unproven vs Stale.
    // 'is_dirty' is set to false as 'next' is read-only and doesn't enforce hygiene.
    let context = RepoContext {
        head_sha: head_sha.to_string(),
        is_dirty: false,
    };

    let output: Vec<_> = tasks
        .iter()
        .map(|t| {
            let status = t.derive_status(&context);
            serde_json::json!({
                "id": t.id,
                "slug": t.slug,
                "title": t.title,
                "status": status.to_string(),
                "test_cmd": t.test_cmd
            })
        })
        .collect();
    println!("{}", serde_json::to_string_pretty(&output)?);
    Ok(())
}

fn print_human(tasks: &[&Task], graph: &TaskGraph) {
    println!("{} Actionable Tasks (frontier):", "üöÄ".cyan());

    if tasks.is_empty() {
        println!("   (All claims proven or none defined)");
        return;
    }

    // We can assume graph.head_sha() is consistent with the context used to build the graph.
    // Ideally TaskGraph would expose its context, but constructing one here is low cost.
    let context = RepoContext {
        head_sha: graph.head_sha().to_string(),
        is_dirty: false,
    };

    for task in tasks {
        let derived = task.derive_status(&context);
        let icon = status_icon(derived);
        println!(
            "   {} [{}] {} ({})",
            icon,
            task.slug.yellow(),
            task.title,
            derived.to_string().dimmed()
        );

        let blocked = graph.get_blocked_by(task.id);
        if !blocked.is_empty() {
            let names: Vec<_> = blocked.iter().map(|t| t.slug.as_str()).collect();
            println!(
                "      ‚Ñπ unblocks: {}",
                names.join(", ").dimmed()
            );
        }
    }
}

fn status_icon(status: DerivedStatus) -> colored::ColoredString {
    match status {
        DerivedStatus::Broken => "‚úó".red(),
        DerivedStatus::Stale => "‚ö°".yellow(),
        DerivedStatus::Unproven => "‚óã".dimmed(),
        DerivedStatus::Proven => "‚úì".green(),
        DerivedStatus::Attested => "!".blue(),
    }
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/handlers/stale.rs
//! Handler for the `stale` command.

use anyhow::Result;
use colored::Colorize;
use roadmap::engine::context::RepoContext;
use roadmap::engine::db::Db;
use roadmap::engine::repo::TaskRepo;
use roadmap::engine::types::DerivedStatus;

/// Scans for and lists all tasks with stale proofs.
///
/// # Errors
/// Returns error if database query fails.
pub fn handle() -> Result<()> {
    let conn = Db::connect()?;
    let repo = TaskRepo::new(&conn);
    let tasks = repo.get_all()?;
    let context = RepoContext::new()?;
    let head_sha = context.head_sha();
    let short_head = &head_sha[..7.min(head_sha.len())];

    let stale_tasks: Vec<_> = tasks
        .iter()
        .filter(|t| matches!(t.derive_status(&context), DerivedStatus::Stale))
        .collect();

    if stale_tasks.is_empty() {
        println!("{} No stale tasks found. The truth is fresh.", "‚úì".green());
        return Ok(());
    }

    println!("{} Found {} stale tasks:", "‚ö°".yellow(), stale_tasks.len());
    println!("   Current HEAD: {}", short_head.dimmed());
    println!();

    for task in stale_tasks {
        if let Some(proof) = &task.proof {
            let proof_sha = &proof.git_sha[..7.min(proof.git_sha.len())];

            println!(
                "   [{}] {}",
                task.slug.yellow().bold(),
                task.title
            );
            println!(
                "     last proven at: {}  (diff: {})",
                proof_sha.dimmed(),
                "HEAD moved".red()
            );
        }
    }

    Ok(())
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/handlers/status.rs
//! Handler for the `status` command.

use anyhow::Result;
use colored::Colorize;
use roadmap::engine::context::RepoContext;
use roadmap::engine::db::Db;
use roadmap::engine::graph::TaskGraph;
use roadmap::engine::repo::TaskRepo;

/// Displays the current project status.
///
/// # Errors
/// Returns error if database query fails.
pub fn handle() -> Result<()> {
    let conn = Db::connect()?;
    let repo = TaskRepo::new(&conn);
    let graph = TaskGraph::build(&conn)?;
    let context = RepoContext::new()?;
    let head_sha = context.head_sha();

    println!("{} Roadmap Status", "üìä".cyan());

    if let Some(id) = repo.get_active_task_id()? {
        if let Some(task) = repo.find_by_id(id)? {
            println!(
                "   Focus: [{}] {} ({})",
                task.slug.yellow(),
                task.title,
                task.derive_status(&context).to_string().dimmed()
            );
        }
    }

    let frontier = graph.get_frontier();
    if !frontier.is_empty() {
        println!("\n   Next up:");
        for task in frontier.iter().take(3) {
            println!("     - [{}] {}", task.slug.dimmed(), task.title);
        }
    }

    println!("\n   Repo HEAD: {}", &head_sha[..7.min(head_sha.len())].dimmed());

    Ok(())
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/handlers/why.rs
//! Handler for the `why` command.

use anyhow::Result;
use colored::Colorize;
use roadmap::engine::context::RepoContext;
use roadmap::engine::db::Db;
use roadmap::engine::repo::ProofRepo;
use roadmap::engine::resolver::TaskResolver;
use roadmap::engine::types::{DerivedStatus, Proof};

/// Explains the status of a task and shows its audit log.
///
/// # Errors
/// Returns error if task resolution or DB query fails.
pub fn handle(task_ref: &str) -> Result<()> {
    let conn = Db::connect()?;
    let proof_repo = ProofRepo::new(&conn);
    let context = RepoContext::new()?;
    let head_sha = context.head_sha();

    let resolver = TaskResolver::new(&conn);
    let result = resolver.resolve(task_ref)?;
    let task = result.task;

    let derived = task.derive_status(&context);
    let history = proof_repo.get_history(task.id)?;

    println!(
        "{} [{}] {}",
        status_icon(derived),
        task.slug.cyan().bold(),
        task.title
    );
    println!("   Status:  {} ({})", derived, derived.color_hint().dimmed());
    println!("   Repo:    {}", head_sha.dimmed());
    println!();

    print_explanation(derived, task.proof.as_ref(), head_sha);
    println!();
    print_history(&history);

    Ok(())
}

fn status_icon(status: DerivedStatus) -> colored::ColoredString {
    match status {
        DerivedStatus::Proven => "‚úì".green(),
        DerivedStatus::Stale => "‚ö°".yellow(),
        DerivedStatus::Broken => "‚úó".red(),
        DerivedStatus::Unproven => "‚óã".dimmed(),
        DerivedStatus::Attested => "!".blue(),
    }
}

fn print_explanation(status: DerivedStatus, proof: Option<&Proof>, head: &str) {
    match status {
        DerivedStatus::Stale => explain_stale(proof, head),
        DerivedStatus::Attested => explain_attested(proof),
        DerivedStatus::Proven => explain_proven(proof),
        DerivedStatus::Unproven => explain_unproven(),
        DerivedStatus::Broken => explain_broken(proof),
    }
}

fn explain_stale(proof: Option<&Proof>, head: &str) {
    if let Some(p) = proof {
        println!("{} Proof exists, but repo has moved.", "reason:".yellow());
        println!("         Proof SHA:   {}", &p.git_sha[..7.min(p.git_sha.len())]);
        println!("         Current SHA: {}", &head[..7.min(head.len())]);
    }
}

fn explain_attested(proof: Option<&Proof>) {
    if let Some(p) = proof {
        let reason = p.attested_reason.as_deref().unwrap_or("Unknown");
        println!("{} Manually attested by human.", "reason:".blue());
        println!("         Note: \"{reason}\"");
    }
}

fn explain_proven(proof: Option<&Proof>) {
    if let Some(p) = proof {
        println!(
            "{} Valid proof exists for SHA {}.",
            "reason:".green(),
            &p.git_sha[..7.min(p.git_sha.len())]
        );
    }
}

fn explain_unproven() {
    println!("{} No proof has ever been recorded for this task.", "reason:".yellow());
}

fn explain_broken(proof: Option<&Proof>) {
    println!("{} The last verification attempt failed.", "reason:".red());
    if let Some(p) = proof {
        if !p.stderr.is_empty() {
            println!("\n{}:", "stderr".red());
            for line in p.stderr.lines().take(5) {
                println!("  {}", line.dimmed());
            }
        }
    }
}

fn print_history(history: &[Proof]) {
    println!("{}", "Audit Log:".dimmed().underline());
    if history.is_empty() {
        println!("   (No history)");
        return;
    }

    for proof in history {
        let sha = &proof.git_sha[..7.min(proof.git_sha.len())];
        let status = if proof.attested_reason.is_some() {
            "ATTESTED".blue()
        } else if proof.exit_code == 0 {
            "PASS    ".green()
        } else {
            "FAIL    ".red()
        };

        println!(
            "   {}  {}  {}  {}",
            proof.timestamp.dimmed(),
            sha.yellow(),
            status,
            format!("{}ms", proof.duration_ms).dimmed()
        );
    }
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/lib.rs
pub mod engine;

#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/main.rs
mod handlers;

use anyhow::Result;
use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(name = "roadmap", version, about = "Git for your Intent")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand, Clone)]
enum Commands {
    /// Initialize the roadmap repository
    Init,
    /// Add a new task
    Add {
        title: String,
        #[arg(long, short = 'b')]
        blocks: Option<String>,
        #[arg(long, short = 'a')]
        after: Option<String>,
        #[arg(long, short = 't')]
        test: Option<String>,
        /// File glob patterns to scope this task (e.g., "src/auth/**")
        #[arg(long, short = 's')]
        scope: Option<Vec<String>>,
    },
    /// Show next actionable tasks
    Next {
        #[arg(long)]
        json: bool,
    },
    /// List all tasks
    List,
    /// Set active task
    Do {
        task: String,
        /// Strict mode: require exact ID or slug (no fuzzy matching)
        #[arg(long)]
        strict: bool,
    },
    /// Run verification for active task
    Check {
        /// Mark complete without verification (creates ATTESTED, not DONE)
        #[arg(long)]
        force: bool,
        /// Reason for manual attestation (required with --force)
        #[arg(long, requires = "force")]
        reason: Option<String>,
    },
    /// Show current status
    Status,
    /// Explain the status of a specific task
    Why {
        task: String,
    },
    /// Scan for invalidated (stale) proofs
    Stale,
    /// Show chronological verification history
    History {
        /// Number of entries to show
        #[arg(long, default_value = "20")]
        limit: usize,
    },
}

fn main() -> Result<()> {
    let cli = Cli::parse();

    match cli.command {
        Commands::Init | Commands::Add { .. } | Commands::Do { .. } | Commands::Check { .. } => {
            dispatch_write_ops(cli.command)
        }
        Commands::Next { .. }
        | Commands::List
        | Commands::Status
        | Commands::Why { .. }
        | Commands::Stale
        | Commands::History { .. } => dispatch_read_ops(cli.command),
    }
}

fn dispatch_write_ops(cmd: Commands) -> Result<()> {
    match cmd {
        Commands::Init => handlers::init::handle(),
        Commands::Add {
            title,
            blocks,
            after,
            test,
            scope,
        } => handlers::add::handle(
            &title,
            blocks.as_deref(),
            after.as_deref(),
            test.as_deref(),
            scope,
        ),
        Commands::Do { task, strict } => handlers::do_task::handle(&task, strict),
        Commands::Check { force, reason } => handlers::check::handle(force, reason.as_deref()),
        _ => unreachable!("Invalid write command dispatch"),
    }
}

fn dispatch_read_ops(cmd: Commands) -> Result<()> {
    match cmd {
        Commands::Next { json } => handlers::next::handle(json),
        Commands::List => handlers::list::handle(),
        Commands::Status => handlers::status::handle(),
        Commands::Why { task } => handlers::why::handle(&task),
        Commands::Stale => handlers::stale::handle(),
        Commands::History { limit } => handlers::history::handle(limit),
        _ => unreachable!("Invalid read command dispatch"),
    }
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/panic.rs
fn main() { panic!("Critical Failure Detected"); }

#__SLOPCHOP_END__#

