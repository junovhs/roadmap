SYSTEM MANDATE: THE SLOPCHOP PROTOCOL
ROLE: High-Integrity Systems Architect (NASA/JPL Standard).
CONTEXT: You are coding inside a strict environment enforced by SlopChop.

THE 3 LAWS (Non-Negotiable):

1. LAW OF ATOMICITY
   - Files: MUST be < 2000 tokens.
   - Action: Split immediately if larger.

2. LAW OF COMPLEXITY
   - Cyclomatic Complexity: MUST be <= 8 per function.
   - Nesting Depth: MUST be <= 3 levels.
   - Function Arguments: MUST be <= 5 parameters.

3. LAW OF PARANOIA
   - Use Result<T, E> for I/O and fallible operations.
   - NO .unwrap() or .expect() calls.

CONTEXT STRATEGY (How to drive):

1. IF you receive 'SIGNATURES.txt' (The Map):
   - You are in ARCHITECT MODE.
   - Do NOT write code yet.
   - Analyze the map to locate the specific files relevant to the user's request.
   - INSTRUCT the user to pack those files:
     'Please run: slopchop pack src/foo.rs src/bar.rs --copy'

2. IF you receive 'context.txt' (Source Code):
   - You are in DEVELOPER MODE.
   - You have the implementation details.
   - PROCEED to write the solution using the Output Format below.

### ROADMAP SYSTEM
- Update exclusively via the ===ROADMAP=== block using this exact syntax:

===ROADMAP===
CHECK
id = task-id
UNCHECK
id = another-task-id
ADD
id = new-task-123
text = Description of the new task
section = v0.9.0
test = tests/some_test.rs::test_name
UPDATE
id = existing-task
text = Updated description
DELETE
id = obsolete-task
===ROADMAP===

Valid commands:
- CHECK / UNCHECK  toggle done/pending
- ADD  create new task (id + text required, section and test optional)
- UPDATE  modify existing task
- DELETE  remove task

Never emit or reference ROADMAP.md or the old markdown checklist format.

OUTPUT FORMAT (MANDATORY):

1. Explain the changes (Technical Plan):
   - Must start with "GOAL:"
   - Must include "CHANGES:" list

#__SLOPCHOP_PLAN__#
GOAL: Refactor authentication module.
CHANGES:
1. Extract user validation to new file.
2. Update config parser.
#__SLOPCHOP_END__#

2. Declare the plan (Manifest):

#__SLOPCHOP_MANIFEST__#
path/to/file1.rs
path/to/file2.rs [NEW]
#__SLOPCHOP_END__#

3. Provide EACH file:

#__SLOPCHOP_FILE__#  path/to/file1.rs
// Complete file content - no truncation allowed
#__SLOPCHOP_END__#

4. Update the Roadmap (if applicable):
   - Use this block to CHECK/ADD/UPDATE tasks in tasks.toml

===ROADMAP===
CHECK
id = task-id
ADD
id = new-task-123
text = Implement dead-code audit
section = v0.9.0
===ROADMAP===

RULES:
- Do NOT use markdown code blocks (triple backticks). The #__SLOPCHOP_FILE__#  delimiters ARE the fence.
- You MAY use markdown inside file content.
- Every file in the manifest MUST have a matching #__SLOPCHOP_FILE__#  block.
- Paths must match exactly.
- Do NOT truncate files (No "// ...").

ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
BEGIN CODEBASE
ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½

#__SLOPCHOP_FILE__# Cargo.toml
[package]
name = "roadmap"
version = "0.1.0"
edition = "2021"
description = "Git for your Intent: A dependency-graph based project manager."

[dependencies]
rusqlite = { version = "0.32", features = ["bundled"] }
clap = { version = "4.5", features = ["derive"] }
petgraph = "0.6"
colored = "2.1"
thiserror = "2.0"
anyhow = "1.0"
chrono = "0.4"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

[dev-dependencies]
tempfile = "3.10"
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# README.md
# Roadmap (Project Cortex)

> **Git for your Intent.**
> A dependency-graph based project manager that treats task completion as a compile-time correctness problem.

---

## 1. The Philosophy

Most project management tools (JIRA, Trello, text files, `TODO.md`) are **Loggers**. They rely on the user to honestly report the state of the world. They allow "split-brain" scenarios where the documentation says a task is done, but the code says otherwise.

**Roadmap** is a **State Machine**.

1.  **Graph, not List:** Projects are Directed Acyclic Graphs (DAGs). You cannot build the roof before the foundation. Roadmap enforces this topologically.
2.  **Trust, but Verify:** A task is not `DONE` until a verification command (unit test, script, build check) returns Exit Code 0.
3.  **Local Velocity:** Built in Rust on SQLite. <10ms startup time. Designed to run inside tight Agent loops or shell prompts.
4.  **Agent-First:** The CLI is designed to be the "Ground Truth" for AI Agents, preventing hallucinated progress by forcing them to satisfy the dependency graph.

---

## 2. Architecture

### The Data Layer (`.roadmap/state.db`)
We reject TOML/JSON for state storage. Text parsing is O(N); SQL is O(1).
We use **SQLite** via `rusqlite` to maintain ACID compliance for project state.

**Core Schema:**
*   **Tasks:** Nodes in the graph. Contain the `verify_cmd` (e.g., `cargo test foo`).
*   **Dependencies:** Edges in the graph. A task cannot be `ACTIVE` if its parent is not `DONE`.
*   **State:** Key-value store for the "Current Context" (what the user/agent is working on *right now*).

### The Graph Engine
We use `petgraph` to model dependencies in memory.
*   **Topological Sort:** Used to determine the "Next Actionable Task."
*   **Cycle Detection:** Prevents "A blocks B blocks A" logic errors.

### The Verification Layer ("Local CI")
Roadmap is **tool-agnostic**. It does not know about Rust, Python, or SlopChop. It only knows **Shell Commands** and **Exit Codes**.
*   If `verify_cmd` returns `0`, the state transitions to `DONE`.
*   If `verify_cmd` returns `!= 0`, the state remains `ACTIVE`.

---

## 3. The "God Mode" Interface

The CLI is designed for speed (Human) and determinism (Agent).

### `roadmap init`
Initializes `.roadmap/state.db`. Detects the project type (Rust/Node/Python) to set default test runner templates.

### `roadmap add`
Natural language intent parsing.
```bash
# Human style
roadmap add "Add Dark Mode" after "UI Framework"

# Agent style (Strict)
roadmap add "feat-dark-mode" --blocks "feat-settings-page"
```
*   **Fuzzy Matching:** Finds "UI Framework" task ID automatically.
*   **Graph Insertion:** Immediately validates acyclicity.

### `roadmap next` (The Critical Path)
Calculates the **Critical Path**. Returns only tasks where `in_degree == 0` (unblocked) and `status != DONE`.
```text
ðŸŽ¯ FOCUS: [db-setup] Initialize SQLite Schema
   â””â”€ ðŸš§ BLOCKS: [impl-types] Define core structs
```

### `roadmap do <task>`
Context switching. Sets the global `active_task` pointer.
*   **Human:** "I am working on this now."
*   **Agent:** "I am focusing my context window on this problem."

### `roadmap check`
The compilation step for your project management.
1.  Retrieves `verify_cmd` for the active task.
2.  Executes it.
3.  **Success:** Marks DONE, unblocks children, updates graph.
4.  **Failure:** Prints stderr, refuses to update state.

---

## 4. Comparison to Alternatives

| Feature | Beads (Python) | Roadmap (Rust) |
| :--- | :--- | :--- |
| **Storage** | SQLite + JSONL (Sync logic) | SQLite (Pure ACID) |
| **Topology** | Loose references | **Strict DAG** |
| **Completion** | "I say it's done" | **"The test says it's done"** |
| **Speed** | ~500ms (Python startup) | **<10ms** (Native binary) |
| **Role** | Long-term Memory | **Active Kernel** |

---

## 5. Development Status (Sitrep)

**Current Version:** v0.1.0 (Scaffold)

**Implemented:**
*   [x] Project Structure (Cargo workspace)
*   [x] Database Engine (`src/engine/db.rs`): Schema creation & migration.
*   [x] Data Types (`src/engine/types.rs`): Task status enum logic.
*   [x] Basic CLI (`src/main.rs`): Argument parsing.

**Immediate Next Steps (The Plan):**
1.  **Graph Logic:** Implement `petgraph` integration to handle insertions and topological sorting.
2.  **The "Add" Parser:** Implement fuzzy string matching to link tasks by name (e.g., "Add X after Y").
3.  **The "Check" Runner:** Implement `std::process::Command` execution for verification.
4.  **TUI:** Implement `roadmap zen` (Ratatui interface) for a live project dashboard.

## 6. Usage for AI Agents

If you are an AI Agent reading this, your instructions are simple:

1.  **Do not hallucinate tasks.** Run `roadmap next` to see what is actually required.
2.  **Do not mark tasks done.** Run `roadmap check` and let the compiler decide.
3.  **Respect the Graph.** You cannot work on a task if its dependencies are not met.

---

*Est. 2025 - "Out-Sciencing the competition."*

#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# slopchop.toml
# slopchop.toml
[rules]
max_file_tokens = 2000
max_cyclomatic_complexity = 8
max_nesting_depth = 3
max_function_args = 5
max_function_words = 5
ignore_naming_on = ["tests", "spec"]

# No project type detected. Configure commands manually:
# [commands]
# check = "your-lint-command"
# fix = "your-fix-command"

#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/engine/db.rs
use anyhow::{Context, Result};
use rusqlite::Connection;
use std::fs;
use std::path::Path;

const DB_DIR: &str = ".roadmap";
const DB_FILE: &str = "state.db";

pub struct Db;

impl Db {
    /// Initializes the .roadmap directory and `SQLite` database schema.
    ///
    /// # Errors
    /// Returns error if directory creation, DB opening, or migration fails.
    pub fn init() -> Result<()> {
        if !Path::new(DB_DIR).exists() {
            fs::create_dir(DB_DIR).context("Failed to create .roadmap directory")?;
        }

        let db_path = Path::new(DB_DIR).join(DB_FILE);
        let conn = Connection::open(db_path).context("Failed to open database")?;

        Self::migrate(&conn)?;

        Ok(())
    }

    /// Connects to an existing database.
    ///
    /// # Errors
    /// Returns error if the database file does not exist or cannot be opened.
    pub fn connect() -> Result<Connection> {
        let db_path = Path::new(DB_DIR).join(DB_FILE);
        if !db_path.exists() {
            anyhow::bail!("Roadmap not initialized. Run `roadmap init` first.");
        }
        let conn = Connection::open(db_path).context("Failed to open database")?;
        Ok(conn)
    }

    /// Applies the schema migrations.
    fn migrate(conn: &Connection) -> Result<()> {
        conn.execute(
            "CREATE TABLE IF NOT EXISTS tasks (
                id INTEGER PRIMARY KEY,
                slug TEXT UNIQUE NOT NULL,
                title TEXT NOT NULL,
                status TEXT NOT NULL,
                test_cmd TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                context_files TEXT
            )",
            [],
        )
        .context("Failed to create tasks table")?;

        conn.execute(
            "CREATE TABLE IF NOT EXISTS dependencies (
                blocker_id INTEGER,
                blocked_id INTEGER,
                PRIMARY KEY (blocker_id, blocked_id),
                FOREIGN KEY(blocker_id) REFERENCES tasks(id),
                FOREIGN KEY(blocked_id) REFERENCES tasks(id)
            )",
            [],
        )
        .context("Failed to create dependencies table")?;

        conn.execute(
            "CREATE TABLE IF NOT EXISTS state (
                key TEXT PRIMARY KEY,
                value TEXT
            )",
            [],
        )
        .context("Failed to create state table")?;

        Ok(())
    }
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/engine/graph.rs
use super::types::{Task, TaskStatus};
use anyhow::{bail, Result};
use petgraph::algo::is_cyclic_directed;
use petgraph::graphmap::DiGraphMap;
use rusqlite::Connection;
use std::collections::HashMap;

pub struct TaskGraph {
    graph: DiGraphMap<i64, ()>,
    tasks: HashMap<i64, Task>,
}

impl TaskGraph {
    /// Loads the entire graph from the database into memory.
    ///
    /// # Errors
    /// Returns error if SQL query fails.
    pub fn build(conn: &Connection) -> Result<Self> {
        let mut graph = DiGraphMap::new();
        let mut task_map = HashMap::new();

        // 1. Load Nodes
        let mut stmt = conn.prepare("SELECT id, slug, title, status, test_cmd, created_at FROM tasks")?;
        let rows = stmt.query_map([], |row| {
            let status_str: String = row.get(3)?;
            Ok(Task {
                id: row.get(0)?,
                slug: row.get(1)?,
                title: row.get(2)?,
                status: TaskStatus::from(status_str),
                test_cmd: row.get(4)?,
                created_at: row.get(5)?,
            })
        })?;

        for t in rows {
            let task = t?;
            graph.add_node(task.id);
            task_map.insert(task.id, task);
        }

        // 2. Load Edges
        let mut stmt = conn.prepare("SELECT blocker_id, blocked_id FROM dependencies")?;
        let edge_rows = stmt.query_map([], |row| {
            Ok((row.get::<_, i64>(0)?, row.get::<_, i64>(1)?))
        })?;

        for e in edge_rows {
            let (source, target) = e?;
            graph.add_edge(source, target, ());
        }

        Ok(Self { graph, tasks: task_map })
    }

    /// Checks if the graph is valid (no cycles).
    ///
    /// # Errors
    /// Returns error if a cycle is detected.
    pub fn validate(&self) -> Result<()> {
        if is_cyclic_directed(&self.graph) {
            bail!("Cycle detected in task dependencies! A blocks B blocks A.");
        }
        Ok(())
    }

    /// Returns the "Next" actionable tasks (Topological sort filtered by status).
    #[must_use]
    pub fn get_critical_path(&self) -> Vec<&Task> {
        let mut actionable = Vec::new();

        for (id, task) in &self.tasks {
            if task.status == TaskStatus::Done {
                continue;
            }

            if !self.is_task_blocked(*id) {
                actionable.push(task);
            }
        }

        // Sort by ID to keep it deterministic for now
        actionable.sort_by_key(|t| t.id);
        actionable
    }

    fn is_task_blocked(&self, task_id: i64) -> bool {
        let blockers = self.graph.neighbors_directed(task_id, petgraph::Direction::Incoming);
        for source_id in blockers {
            if let Some(parent) = self.tasks.get(&source_id) {
                if parent.status != TaskStatus::Done {
                    return true;
                }
            }
        }
        false
    }
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/engine/mod.rs
pub mod db;
pub mod graph;
pub mod repo;
pub mod types;
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/engine/repo.rs
use super::types::{Task, TaskStatus};
use anyhow::{Context, Result};
use rusqlite::{params, Connection, OptionalExtension};

pub struct TaskRepo {
    conn: Connection,
}

impl TaskRepo {
    #[must_use]
    pub fn new(conn: Connection) -> Self {
        Self { conn }
    }

    /// Adds a new task to the database.
    ///
    /// # Errors
    /// Returns error if the INSERT fails.
    pub fn add(&self, slug: &str, title: &str) -> Result<i64> {
        self.conn.execute(
            "INSERT INTO tasks (slug, title, status) VALUES (?1, ?2, ?3)",
            params![slug, title, TaskStatus::Pending.to_string()],
        )
        .context("Failed to insert task")?;
        
        let id = self.conn.last_insert_rowid();
        Ok(id)
    }

    /// Links two tasks (dependency).
    ///
    /// # Errors
    /// Returns error if the INSERT fails.
    pub fn link(&self, source_id: i64, target_id: i64) -> Result<()> {
        self.conn.execute(
            "INSERT OR IGNORE INTO dependencies (blocker_id, blocked_id) VALUES (?1, ?2)",
            params![source_id, target_id],
        )?;
        Ok(())
    }

    /// Retrieves all tasks.
    ///
    /// # Errors
    /// Returns error if the SELECT fails.
    pub fn get_all(&self) -> Result<Vec<Task>> {
        let mut stmt = self.conn.prepare("SELECT id, slug, title, status, test_cmd, created_at FROM tasks")?;
        let rows = stmt.query_map([], |row| {
            let status_str: String = row.get(3)?;
            Ok(Task {
                id: row.get(0)?,
                slug: row.get(1)?,
                title: row.get(2)?,
                status: TaskStatus::from(status_str),
                test_cmd: row.get(4)?,
                created_at: row.get(5)?,
            })
        })?;

        let mut tasks = Vec::new();
        for task in rows {
            tasks.push(task?);
        }
        Ok(tasks)
    }

    /// Finds a task by its slug.
    ///
    /// # Errors
    /// Returns error if the query fails.
    pub fn find_by_slug(&self, slug: &str) -> Result<Option<Task>> {
        self.conn.query_row(
            "SELECT id, slug, title, status, test_cmd, created_at FROM tasks WHERE slug = ?1",
            params![slug],
            |row| {
                let status_str: String = row.get(3)?;
                Ok(Task {
                    id: row.get(0)?,
                    slug: row.get(1)?,
                    title: row.get(2)?,
                    status: TaskStatus::from(status_str),
                    test_cmd: row.get(4)?,
                    created_at: row.get(5)?,
                })
            },
        )
        .optional()
        .context("Failed to find task by slug")
    }
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/engine/types.rs
use std::fmt;

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum TaskStatus {
    Pending,
    Active,
    Done,
    Blocked,
}

impl fmt::Display for TaskStatus {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            TaskStatus::Pending => write!(f, "PENDING"),
            TaskStatus::Active => write!(f, "ACTIVE"),
            TaskStatus::Done => write!(f, "DONE"),
            TaskStatus::Blocked => write!(f, "BLOCKED"),
        }
    }
}

impl From<String> for TaskStatus {
    fn from(s: String) -> Self {
        match s.as_str() {
            "ACTIVE" => TaskStatus::Active,
            "DONE" => TaskStatus::Done,
            "BLOCKED" => TaskStatus::Blocked,
            _ => TaskStatus::Pending,
        }
    }
}

#[derive(Debug, Clone)]
pub struct Task {
    pub id: i64,
    pub slug: String,
    pub title: String,
    pub status: TaskStatus,
    pub test_cmd: Option<String>,
    pub created_at: String, // Simplified for now, could be DateTime
}
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/lib.rs
pub mod engine;
#__SLOPCHOP_END__#

#__SLOPCHOP_FILE__# src/main.rs
use anyhow::Result;
use clap::{Parser, Subcommand};
use colored::Colorize;
use roadmap::engine::db::Db;
use roadmap::engine::graph::TaskGraph;
use roadmap::engine::repo::TaskRepo;

#[derive(Parser)]
#[command(name = "roadmap", version, about = "Git for your Intent", long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Initialize the roadmap repository
    Init,
    /// Add a new task
    Add {
        title: String,
        /// Task ID this new task blocks (is a dependency of)
        #[arg(long, short = 'b')]
        blocks: Option<String>,
        /// Task ID that blocks this new task (is a prerequisite)
        #[arg(long, short = 'a')]
        after: Option<String>,
    },
    /// List next actionable tasks (Topological Sort)
    Next,
    /// List all tasks
    List,
}

fn main() -> Result<()> {
    let cli = Cli::parse();

    match &cli.command {
        Commands::Init => handle_init(),
        Commands::Add {
            title,
            blocks,
            after,
        } => handle_add(title, blocks.as_deref(), after.as_deref()),
        Commands::Next => handle_next(),
        Commands::List => handle_list(),
    }
}

fn handle_init() -> Result<()> {
    Db::init()?;
    println!("{} Initialized .roadmap/state.db", "âœ“".green());
    Ok(())
}

fn handle_add(title: &str, blocks: Option<&str>, after: Option<&str>) -> Result<()> {
    let _conn = Db::connect()?;
    // Placeholder logic until full graph engine is ready
    println!("{} Adding task: {title}", "âžœ".cyan());
    if let Some(b) = blocks {
        println!("   Blocks: {b}");
    }
    if let Some(a) = after {
        println!("   After:  {a}");
    }
    // Logic to insert into DB goes here
    Ok(())
}

fn handle_next() -> Result<()> {
    let conn = Db::connect()?;
    let graph = TaskGraph::build(&conn)?;
    let critical_path = graph.get_critical_path();

    println!("{} Next Actionable Tasks:", "âžœ".cyan());
    if critical_path.is_empty() {
        println!("   (No pending tasks found)");
    } else {
        for task in critical_path {
            println!("   [{}] {}", task.slug.yellow(), task.title);
        }
    }
    Ok(())
}

fn handle_list() -> Result<()> {
    let conn = Db::connect()?;
    let repo = TaskRepo::new(conn);
    let tasks = repo.get_all()?;

    println!("{} All Tasks:", "âžœ".cyan());
    for task in tasks {
        println!("   [{}] {} ({})", task.slug.blue(), task.title, task.status);
    }
    Ok(())
}
#__SLOPCHOP_END__#


ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
END CODEBASE
ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½

SLOPCHOP CONSTRAINTS:
? Files < 2000 tokens
? Complexity <= 8
? Nesting <= 3
? Args <= 5
? No .unwrap() or .expect()
? Use SlopChop Format (#__SLOPCHOP_FILE__# ...)
? Roadmap updates  tasks.toml via ===ROADMAP=== block only
